{"name":"Daneel","tagline":"A framework for CraftStudio","body":"[craftstudio]: http://craftstud.io\r\n[CSscriptingreference]: http://craftstudio.wikia.com/wiki/Scripting_Reference/Index\r\n[Daneelfunctionreference]: http://florent-poujol.fr/content/craftstudio/daneel/doc/\r\n[downloadlink]: http://florent-poujol.fr/content/craftstudio/daneel/craftstudio_daneel_v1.1.0.cspack\r\n\r\n\r\n# Daneel\r\n\r\nDaneel is a framework for [CraftStudio][] that aims to sweeten and shorten the code you write, to extend and render more flexible to use the API, as well as to bring news functionalities.\r\n\r\nDaneel never deprecate anything from the current CraftStudio's API which remains usable in its entirety [as described in the scripting reference][CSscriptingreference] on the official wiki.  \r\nDaneel mostly add new objects, new functions on existing objects and sometimes allow to pass different argument types and new arguments on existing functions.\r\n\r\n- [Overview](#overview)\r\n- [Installation](#installation)\r\n- [Configuration](#configuration)\r\n- [Loading Daneel](#loading-daneel)\r\n- [Conventions](#conventions)\r\n- [Dynamic getters and setters](#dynamic-getters-and-setters)\r\n- [Dynamic access to components](#dynamic-access-to-components)\r\n- [Mass-setting on gameObjects and components](#mass-setting-on-gameobjects-and-components)\r\n- [Debugging](#debugging)\r\n- [Raycasting](#raycasting)\r\n- [Trigger messages](#trigger-messages)\r\n- [Mouse messages](#mouse-messages)\r\n- [Events](#events)\r\n- [Hotkeys](#hotkeys)\r\n- [Miscellaneous](#miscellaneous)\r\n- [Functions list](#functions-list)\r\n- [Changelog](#changelog)\r\n\r\n\r\n## Overview\r\n\r\nCall getters and setters as if they were variable :\r\n    \r\n    self.gameObject.name -- same as self.gameObject:GetName()\r\n    self.gameObject.name = \"new name\" -- same as self.gameObject:SetName(\"new name\")\r\n\r\nAccess any component (including ScriptedBehaviors with a few configuration) on the gameObject in a similar way, like you can already do with the transform :\r\n\r\n    self.gameObject.modelRenderer\r\n\r\n    -- the \"getters/setters as variable\" thing also works on components :\r\n    self.gameObject.mapRenderer.map = \"folder/map name\" -- you can also see here that you can use the map name instead of the map asset\r\n    \r\n    -- writing this same line \"the old way\" takes twice as much characters :\r\n    self.gameObject:GetComponent(\"MapRenderer\"):SetMap(CraftStudio.FindAsset(\"folder/map name\", \"Map\"))\r\n\r\nSet variable or call setters in mass on gameObjects and components.\r\n    \r\n    gameObject:Set({\r\n        parent = \"my parent name\",\r\n\r\n        modelRenderer = {\r\n            model = \"model name\"\r\n        }\r\n\r\n        myScript = {\r\n            health = 100\r\n        }\r\n    })\r\n\r\n\r\nAlso : \r\n\r\n- Use the gameObject or asset name instead of the actual object with some functions\r\n- Simpler raycasting with `ray:InstersectsGameObject()` or `ray:Cast()`\r\n- Triggers (they perform a proximity check against some gameObjects and interact with them when they are in range)\r\n- Interact with gameObjects hovered by the mouse\r\n- Events\r\n- Hotkeys (fire events at the push of any button)\r\n\r\nYou can add the public project `Daneel` in CraftStudio and run the game to test some of these features for yourself and read some script examples.  \r\nNote that the project is only visible in the `Community Projects` when my computer and my local server are up. Also, my IP changes frequently, so if you can't connect but find it in the `Community Projects`, you need to remove the project from your list then add it again.\r\n\r\n\r\n## Installation \r\n\r\nFirst [download the package of scripts from this link][downloadlink].\r\n\r\nYou must then import the package in your project.\r\n\r\n- Download the file on your computer\r\n- Go to your project's administration, \"Import/Export\" section.  \r\n- Click the import button (top right), navigate to the location you downloaded the pack in then click \"Open\".  \r\n- Navigate to the \"Script\" tab, select all the scripts then click \"Import\".\r\n\r\n\r\n## Configuration\r\n\r\nSome features only work if a few configuration is done first.\r\nYou will find the configuration table in the `Daneel/Config` script.\r\n    \r\n\r\n## Loading Daneel\r\n\r\nDaneel needs to be loaded before some of its features work, so you need to add the \"Daneel/Behaviors/DaneelBehavior\" script as a ScriptedBehavior in your scene.  \r\nDaneel is garanteed to be loaded by the time functions `Behavior:Start()` begin to be called.  \r\nIt may also be the case from `Behavior:Awake()` functions, but it is not garanteed (it depends on the GameObject initialization order).\r\n\r\nThe global variable `DANEEL_LOADED` is equal to `nil` until Daneel is loaded, where its value is set to `true`.\r\n\r\nAny scripts whose path is set in `Daneel.config.scripts` may implements a `Behavior:DaneelAwake()` function.  \r\nThis function will be called right after Daneel has loaded, before `Behavior:Start()` and **even on scripts that are not ScriptedBehavior**.\r\n\r\n\r\n## Conventions\r\n\r\n* Every getter functions are called GetSomething() instead of FindSomething().\r\n* Every object and function names are pascal-cased, except for functions added to Lua's standard libraries which are all lower-case.\r\n* Every time an argument has to be an asset (like with `modelRenderer:SetModel()`), you may pass the fully-qualified asset name instead.\r\n* Every time an argument has to be a gameObject instance (like with `gameObject:SetParent(parentNameOrInstance[, keepLocalTransform])`), you may pass the gameObject name instead.\r\n* Every time an argument has to be an asset or component type, it is case insensitive.\r\n* Every optional boolean arguments default to false.\r\n\r\n\r\n## Dynamic getters and setters\r\n\r\nGetters and setters functions may be used on gameOjects, components and assets as if they were variables. Their names must begin by \"Get\" or \"Set\" and have the forth letter upper-case (underscore is allowed). Ie : GetSomething() and Get_something() will work, but Getsomething() or getSomething() won't work.\r\n\r\n    \r\n    self.gameObject.transform.localPosition\r\n    -- is the same as\r\n    self.gameObject.transform:GetLocalPosition()\r\n\r\n    self.gameObject.name = \"a new name\"\r\n    -- is the same as \r\n    self.gameObject:SetName(\"a new name\")\r\n    -- note that only one argument (in addition to the working object) can be passed to the function.\r\n\r\nDynamic getters and setters will also work on your ScriptedBehaviors provided you add their Script's fully-qualified path in `Daneel.config.scripts` :\r\n\r\n    Daneel.config = {\r\n        scripts = {\r\n            \"MyScript\",\r\n            \"folder/my other script\", \r\n        }\r\n    }\r\n\r\n\r\n## Dynamic access to components \r\n\r\nAs Daneel introduce the new `gameObject:GetModelRenderer()`, `gameObject:GetMapRenderer()` and `gameObject:GetCamera()` functions, you may now access any component via its variable, like the transform :\r\n\r\n    self.gameObject.modelRenderer.model = Asset.GetModel(\"model name\") -- Asset.GetModel() is an helper of Asset.Get(), an alias of CraftStudio.FindAsset()\r\n    -- is the same as\r\n    self.gameObject:GetComponent(\"ModelRenderer\"):SetModel(CraftStudio.FindAsset(\"model name\", \"Model\"))\r\n\r\n### ScriptedBehaviors\r\n\r\nScriptedBehaviors may also be accessed this way.  \r\nIt just works right away for those who are not nested in a folder and name is pascal-cased. For instance, with a Script whose name is \"MyScript\" :\r\n\r\n    self.gameObject.myScript\r\n    -- is the same as\r\n    self.gameObject:GetScriptedBehavior(CraftStudio.FindAsset(\"MyScript\", \"Script\"))\r\n\r\nScriptedBehaviors who are nested in folders and/or name are not pascal-cased, may be accessed via their aliases as you define them in `Daneel.config.scripts`.\r\n\r\n    Daneel.config = {\r\n        scripts = {\r\n            \"MyScript\",\r\n            \r\n            -- alias = \"fully-qualified Script path\"\r\n            otherScript = \"folder/my other script\",\r\n        }\r\n    }\r\n\r\n    -- in your script, access the scripteBehavior via its alias :\r\n    self.gameObject.otherScript\r\n\r\n\r\n## Mass-setting on gameObjects and components\r\n\r\nFunctions `gameObject:Set()` and `component:Set()` accept a \"params\" argument of type table which allow to set variables or call setters in mass.  \r\n\r\n    gameObject:Set({\r\n        parent = \"my parent name\", -- Set the parent via SetParent()\r\n        myScript = {\r\n            health = 100 -- Set the variable health or call SetHealth(100) if it exists on the 'MyScript' scriptedBaheavior \r\n        }\r\n    })\r\n\r\n    modelRenderer:Set({\r\n        localOrientation = Quaternion:New(1,2,3,4), -- set the local orientation via SetLocalOrientation()\r\n        randomVariable = \"random value\"\r\n    })\r\n\r\n\r\n### Component mass-creation and setting on gameObjects\r\n\r\nWith `gameObject:Set()`, you can easily create new components then optionally initialize them or set existing components (including ScriptedBehaviors).  \r\n\r\n    gameObject:Set({\r\n        modelRenderer = {\r\n            model = \"Model name\"\r\n        }, -- will create a modelRenderer if it does not yet exists, then set its model\r\n\r\n        camera = {}, -- will create a camera component then do nothing, or just do nothing\r\n\r\n        scriptedBehavior = \"Script name\", -- will create a ScriptedBehavior with the \"Script name\" script if it does not yet exists\r\n        \r\n        scriptedBehaviors = {\r\n            \"script name 2\",\r\n            \"script name 3\", -- will create those ScriptedBehaviors if they don't yet exist\r\n            \r\n            [\"script name 4\"] = {\r\n                variableOrSetter = value\r\n            } -- will create a ScriptedBehavior if it does not yet exists, then set it\r\n        },\r\n\r\n        scriptAlias = {\r\n            variableOrSetter = value\r\n        } -- will set the ScriptedBehavior whose name or alias is 'ScriptAlias'\r\n    })\r\n\r\n\r\n**Components**\r\n\r\nJust set the variable of the same name as the component with the first letter lower case. Set the value as a table of parameters. If the component does not yet exists, it will be created. If you want to create a component without initializing it, just leave the table empty.\r\n\r\nYou can also mass-set existing components on gameObjects via `gameObject:SetComponent()` or its helpers (`gameObject:SetModelRenderer()` and the likes).\r\n    \r\n    self.gameObject:SetMapRenderer({params})\r\n    \r\n    -- or (with the dynamic component getters)\r\n    self.gameObject.mapRenderer:Set({params})\r\n\r\n    -- note that you CAN NOT do the following since the components are cached on the gameObject :\r\n    self.gameObject.mapRenderer = {params}\r\n    -- the variable actually exists on the gameObject, so the dynamic call to Set[ComponentType]() does not work\r\n\r\n**ScriptedBehaviors**\r\n\r\nIf you want to add just one scriptedBehavior, you can set the variable `scriptedBehavior` with the script name or asset as value.  \r\nIf you want to add one or more scriptedBehaviors and maybe initialize them or set existing ScriptedBehaviors, set the variable `scriptedBehaviors` (with an \"s\" at the end) with a table as value.  \r\nThis table may contains the script name or asset of new ScriptedBehaviors as value (if you don't want to initialize them) or the script name or asset as key and the parameters table as value (for new or existing ScriptedBehaviors). Existing ScriptedBehaviors may also be set via their name or alias.\r\n\r\n\r\n## Debugging\r\n\r\nFor an easy debugging during development, Daneel feature extensive error reporting and a stack trace. Since these features are pretty heavy on function calls, you can turn these on and off (and you should disable debug when you ship your game).  \r\nIt's turned off by default, so just set the value of the variable `Daneel.config.debug` to `true` to enable it.\r\n\r\n### Error reporting\r\n\r\nIn every functions introduced or modified by Daneel, every arguments are checked for type and value and a comprehensive error message is thrown if needed.  \r\nFor instance, passing false instead of the gameObject's name with `gameObject:GetChild()` would trigger the following error :  \r\n\r\n    GameObject.GetChild(gameObject, name[, recursive]) : Argument 'name' is of type 'boolean' with value 'false' instead of 'string'.\r\n\r\n### Stack Trace\r\n\r\nWhen an error is triggered, Daneel print a \"stack trace\" in the Runtime Report.\r\nThe stack trace nicely shows the history of function calls within the framework that lead to the error and display values received as argument.  \r\nIt reads from top to bottom, the last function called -where the error occurred- at the bottom.  \r\nFor instance, when trying to set the model of a ModelRenderer (to a Model that does not exists) via gameObject:Set() :\r\n\r\n    ~~~~~ Daneel.Debug.StackTrace ~~~~~\r\n    #01 GameObject.Set(GameObject: 'Object1': 14476932, table: 04DAC148)\r\n    #02 Component.Set(ModelRenderer: 31780825, table: 04DAC238)\r\n    #03 ModelRenderer.SetModel(ModelRenderer: 31780825, \"UnknowModel\")\r\n    [string \"Behavior Daneel/Daneel (0)\"]:293: ModelRenderer.SetModel(modelRenderer, modelNameOrAsset) : Argument 'modelNameOrAsset' : model with name 'UnknowModel' was not found.\r\n\r\n### Data types\r\n\r\nThe function `Daneel.Debug.GetType(object)` may returns any of the built-in Lua types or the name of any of the objects introduced by CraftStudio or Daneel : GameObject, ModelRenderer, MapRenderer, Camera, Transform, Script, Model, ModelAnimation, Map, TileSet, Scene, Sound, Ray, RaycastHit, Vector3, Plane or Quaternion.\r\n\r\nIt can also return your own types as you define them in `Daneel.config.objects`. GetType() will return the type for tables that have the object table as a metatable.\r\n\r\n\r\n## Raycasting\r\n\r\nGameObjects who have the `CastableGameObject` ScriptedBehavior are known as **castable gameObjects**.  \r\nThe `RaycastHit` object stores the information regarding the collision between a ray and a gameObject. It may contains the keys distance, normal, hitBlockLocation, adjacentBlockLocation, gameObject and componentType.\r\n\r\nThe function `ray:IntersectsGameObject(gameObject)` returns a RaycastHit if the ray intersects the gameObject, or nil.  \r\nThe function `ray:Cast([gameObjects])` cast the ray against all castable gameObjects (or against the provided set of gameObjects) and returns a table of RaycastHit (which will be empty if no gameObjects have been hit).\r\n\r\n\r\n## Trigger messages\r\n\r\nGameObjects who have the `TriggerableGameObject` ScriptedBehavior are known as **triggerable gameObjects**. They react when they are near triggers.  \r\nTriggers are gameObjects that perform a spherical proximity check each frames against all triggerable gameObjects.  \r\nTriggers must have the `Trigger` ScriptedBehavior and you must set its `radius` public property (don't forget to tick the box).\r\n\r\n* When a triggerable gameObject enters a trigger for the first frame (it is in range this frame, but it wasn't the last frame), the message `OnTriggerEnter` is sent on the gameObject.  \r\n* As long as a gameObject stays in range of one or several trigger(s), the message `OnTriggerStay` is sent on the gameObject (each frame, by each trigger the gameObject is in range of).\r\n* The frame a gameObject leaves a trigger's radius (it is not in range this frame but was in range the last frame), the message `OnTriggerExit` is send on the gameObject.\r\n\r\nEach of these functions receive the trigger gameObject as argument.\r\n\r\n    -- in a ScriptedBehavior attached to a triggerable gameObjects :\r\n    function Behavior:OnTriggerEnter(trigger)\r\n        print(\"The gameObject of name '\"..self.gameObject.name..\"' just reach the trigger of name '\"..trigger.name..\"'.\")\r\n    end\r\n\r\n    function Behavior:OnTriggerStay(trigger)\r\n        if CraftStudio.Input.WasButtonJustRealeased(\"Action\") then\r\n            print(\"The 'Action' button was just released while the gameObject of name '\"..self.gameObject.name..\"' is inside the trigger of name '\"..trigger.name..\"'.\")\r\n        end\r\n    end\r\n    -- a typical use for this is any mechanism that the player can use if he is close enough and press a key\r\n\r\n\r\n## Mouse messages\r\n\r\nGameObjects who have the `MousehoverableGameObject` ScriptedBehavior are known as **mousehoverable gameObjects**. They react when they are hovered by the mouse.  \r\nAdd the `CameraMouseOver` ScriptedBehavior to your camera.\r\n\r\n* When a mousehoverable gameObject is hovered for the first frame (it is hovered this frame, but it wasn't the last frame), the message `OnMouseEnter` is sent on the gameObject.\r\n* As long as the mouse stays over the gameObject, the message `OnMouseOver` is sent on the gameObject.\r\n* The frame the mouse stop hovering over a mousehoverable gameObject (it is not hovered this frame but was hovered the last frame), the message `OnMouseExit` is send on the gameObject.\r\n\r\n\r\n## Events\r\n\r\nDaneel provide a event system that allows to run functions or messages on gameObjects whenever some events happens during runtime.\r\n\r\nYou can register global or local functions to be called whenever an event is fired (the function is said to listen to the event).  \r\nAny arguments may be passed to the function when the event is fired.  \r\n    \r\n    local function ALocalFunction(text)\r\n        print(text)\r\n    end\r\n\r\n    function Behavior:Awake()\r\n        Daneel.Events.Listen(\"EventName\", ALocalFunction) -- same for global functions\r\n\r\n        -- to fire an event, just call the Fire() function\r\n        -- and optionally pass the argument(s) after the event name\r\n        Daneel.Events.Fire(\"EventName\", \"Brace for this event !\")\r\n    end\r\n\r\nYou can also make gameObjects to listen to events. By default, the message of the same name as the event will be sent (and optionally broadcasted) on that gameObject (the function `Behavior:EventName()` wil be called if it exists).  \r\n    \r\n    function Behavior:Awake()\r\n        Daneel.Events.Listen(\"EventName\", self.gameObject) -- the message \"EventName\" will be sent on this gameObject only\r\n        Daneel.Events.Listen(\"EventName\", self.gameObject, \"AnotherMessage\") -- the message \"AnotherMessage\" (instead of \"OnEventName\") will be sent on this gameObject only\r\n        Daneel.Events.Listen(\"EventName\", self.gameObject, \"AnotherMessage\", true) -- the message \"AnotherMessage\" will be sent on this gameObject and all of its children\r\n    end\r\n\r\nIf you want a function or a gameObject to listen to every events, just pass `\"any\"` as the event name.\r\n\r\n\r\n## Hotkeys events\r\n\r\nWhenever you press one of the button whose name is set in `Daneel.config.buttons`, the events named `On[Button name]ButtonJustPressed`, `On[Button name]ButtonDown` and `On[Button name]ButtonJustReleased` are fired.\r\n\r\nThe table `Daneel.config.buttons` may be filled with the button names that you defined in the `Administration > Game Controls` tab.\r\n\r\n    Daneel.config = {\r\n        buttons = {\r\n            \"Action\",\r\n            \"fire\",\r\n        }\r\n    }\r\n\r\n\r\n## Miscellaneous\r\n\r\n### GameObject\r\n\r\n* Create a gameObject with `GameObject.New()` or `GameObject.Instantiate()`.\r\n* Get a gameObject with `GameObject.Get()` and get a child with `gameObject:GetChild()`.\r\n* Add a component on a gameObject with `gameObject:AddComponent()` or its helpers `gameObject:AddModelRenderer()` and the likes, as well as `gameObject:AddScriptedBehavior()`.\r\n- Send a message to a gameObject and all of its descendants with `GameObject.BroadcastMessage()`\r\n\r\n### Asset \r\n\r\nGet an asset with `Asset.Get()` or its helpers `Asset.GetScript()`, `Asset.GetModel()`, ...\r\n\r\n### Scene\r\n\r\nLoad a scene with `Scene.Load()`, append a scene with `Scene.Append()`.\r\n\r\n### Tables as object\r\n\r\nTables returned by `table.new()` or any new table functions introduced by Daneel that returns a table may be used in an object-oriented way. You can also turn any standard table to such table by passing it as argument to table.new().  \r\n\r\n    -- you always can do this :\r\n    table.insert(myTable, value)\r\n\r\n    -- now, you can also do this (like with strings)\r\n    myTable:insert(value)\r\n\r\nThe `table` object has also been extended with many functions that ease the manipulation of tables.\r\n\r\n\r\n## Functions list\r\n\r\n[See the full function reference][daneelfunctionreference] for full explanation on arguments and returned values. \r\nArguments between square brackets are optional.\r\n\r\n### Asset\r\n\r\n* Asset.Get(assetName[, assetType])\r\n    * Asset.GetScript(assetName)\r\n    * Asset.GetModel(assetName)\r\n    * Asset.GetModelAnimation(assetName)\r\n    * Asset.GetMap(assetName)\r\n    * Asset.GetTileSet(assetName)\r\n    * Asset.GetScene(assetName)\r\n    * Asset.GetSound(assetName)\r\n\r\n### Component\r\n\r\n* Component.Set(component, params)\r\n* component:Destroy()\r\n\r\n### Daneel.Debug\r\n\r\n* Daneel.Debug.CheckArgType(argument, argumentName, expectArgumentType[, errorHead, errorEnd])\r\n* Daneel.Debug.CheckOptionalArgType(argument, argumentName, expectArgumentType[, errorHead, errorEnd])\r\n* Daneel.Debug.CheckComponentType(componentType)\r\n* Daneel.Debug.CheckAssetType(assetType)\r\n\r\n* Daneel.Debug.GetType(object[, getLuaTypeOnly])\r\n* error(message[, doNotPrintStacktrace])\r\n* Daneel.Debug.ToRawString(object)\r\n\r\n* Daneel.Debug.StackTrace.BeginFunction(functionName[, ...])\r\n* Daneel.Debug.StackTrace.EndFunction()\r\n* Daneel.Debug.StackTrace.Print()\r\n\r\n### Daneel.Events\r\n\r\n* Daneel.Events.Listen(eventName, function) / Daneel.Events.Listen(eventName, gameObject[, functionName, broadcast])\r\n* Daneel.Events.StopListen(eventName, functionOrGameObject)\r\n* Daneel.Events.Fire(eventName[, ...])\r\n\r\n### Daneel.Utilities\r\n\r\n* Daneel.Utilities.CaseProof(name, set)\r\n\r\n### GameObject\r\n\r\n* GameObject.New(name[, params])\r\n* GameObject.Instantiate(name, sceneNameOrObject[, params])\r\n* GameObject.Get(name)\r\n\r\n* gameObject:SetParent(parentNameOrInstance[, keepLocalTransform])\r\n* gameObject:GetChild(childName[, recursive])\r\n* gameObject:GetChildren([recursive, includeSelf])\r\n* gameObject:SendMessage(functionName[, data])\r\n* gameObject:BroadcastMessage(functionName[, data])\r\n\r\n* gameObject:AddComponent(componentType[, params]) / gameObject:AddComponent(\"ScriptedBehavior\", scriptNameorAsset[, params])\r\n    * gameObject:AddScriptedBehavior(scriptNameOrAsset[, params])\r\n    * gameObject:AddModelRenderer([params])\r\n    * gameObject:AddMapRenderer([params])\r\n    * gameObject:AddCamera([params])\r\n\r\n* gameObject:SetComponent(componentType, params) / gameObject:SetComponent(\"ScriptedBehavior\", scriptNameorAsset, params)\r\n    * gameObject:SetScriptedBehavior(scriptNameOrAsset, params)\r\n    * gameObject:SetModelRenderer(params)\r\n    * gameObject:SetMapRenderer(params)\r\n    * gameObject:SetCamera(params)\r\n    * gameObject:SetTransform(params)\r\n\r\n* gameObject:GetComponent(componentType[, scriptNameOrAsset])\r\n    * gameObject:GetScriptedBehavior(scriptNameOrAsset)\r\n    * gameObject:GetModelRenderer()\r\n    * gameObject:GetMapRenderer()\r\n    * gameObject:GetCamera()\r\n\r\n* gameObject:Destroy()\r\n\r\n### math\r\n\r\n* math.isinteger(value[, errorIfValueIsNotNumber])\r\n\r\n### MapRenderer\r\n\r\n* mapRenderer:SetMap(mapNameOrAsset[, keepTileSet])\r\n* mapRenderer:SetTileSet(tileSetNameOrAsset)\r\n\r\n### ModelRenderer\r\n\r\n* modelRenderer:SetModel(modelNameOrAsset)\r\n* modelRenderer:SetAnimation(animationNameOrAsset)\r\n\r\n### Ray\r\n\r\n* ray:Cast([gameObjects])\r\n* ray:IntersectsGameObject(gameObjectNameOrInstance)\r\n\r\n### RaycastHit\r\n\r\n* RaycastHit.New([distance, normal, hitBlockLocation, adjacentBlockLocation, gameObject])\r\n\r\n### Scene\r\n\r\n* Scene.Load(sceneNameOrAsset)\r\n* Scene.Append(sceneNameOrAsset, gameObjectNameOrInstance)\r\n\r\n### string\r\n\r\n* string.totable(string)\r\n* string.isoneof(string, set[, ignoreCase])\r\n* string.ucfirst(string)\r\n\r\n### table\r\n\r\n* table.new([table])\r\n* table.copy(table)\r\n* table.constainskey(table, key)\r\n* table.constainsvalue(table, value[, ignoreCase])\r\n* table.length(table[, keyType])\r\n* table.print(table)\r\n* table.printmetatable(table)\r\n* table.merge(...)\r\n* table.compare(table1, table2)\r\n* table.combine(keys, values[, returnFalseIfNotSameLength])\r\n* table.removevalue(table, value[, singleRemove])\r\n* table.getkeys(table)\r\n* table.getvalues(table)\r\n* table.getkey(table, value)\r\n\r\n\r\n## Changelog\r\n\r\n### v1.1.0\r\n\r\n- Separated the user config from the \"Daneel\" script\r\n- Dynamic getters and setters works on assets too\r\n- Daneel.Debug.getType() may now also return user-defined types\r\n- The error() function now prints the StackTrace, unless told otherwise (Daneel.Debug.PrintError() is removed)\r\n- Default function names when registering a gameObject to an event are not prefixed by \"On\" anymore\r\n- Fixed various bugs","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}