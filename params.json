{"name":"Daneel","tagline":"A framework for CraftStudio","body":"[craftstudio]: http://craftstud.io\r\n[CSscriptingreference]: http://craftstudio.wikia.com/wiki/Scripting_Reference/Index\r\n[Daneelscriptingreference]: http://florent-poujol.fr/content/craftstudio/daneel/doc/\r\n\r\n\r\n# Daneel\r\n\r\nDaneel is a framework for [CraftStudio][] that aims to sweeten and shorten the code you write, to extend and render more flexible to use the API, as well as to bring news fonctionnalities.\r\n\r\nDaneel never deprecate anything from the current CraftStudio's API which remains usable in its entirety [as decribed in the scripting reference][CSscriptingreference] on the offical wiki.  \r\nDaneel mostly add new objects, new functions on existing objects and sometimes allow to pass different argument types and new arguments on existing functions.\r\n\r\n- [Overview](#overview)\r\n- [Installation](#installation)\r\n- [Configuration](#configuration)\r\n- [Conventions](#conventions)\r\n- [Dynamic getters and setters](#dynamic-getters-and-setters)\r\n- [Dynamic access to components](#dynamic-access-to-components)\r\n- [Mass-setting on gameObjects and components](#mass-setting-on-gameobjects-and-components)\r\n- [Debugging](#debugging)\r\n- [Raycasting](#raycasting)\r\n- [Trigger messages](#trigger-messages)\r\n- [Mouse messages](#mouse-messages)\r\n- [Events](#events)\r\n- [Hotkeys](#hotkeys)\r\n- [Miscellaneous](#miscellaneous)\r\n- [Functions list](#functions-list)\r\n\r\n## <a id=\"overview\"></a>Overview\r\n\r\nCall getters and setters as if they were variable :\r\n    \r\n    self.gameObject.name -- same as self.gameObject:GetName()\r\n    self.gameObject.name = \"new name\" -- same as self.gameObject:SetName(\"new name\")\r\n\r\nAccess any component (including ScriptedBehaviors with a few configuration) on the gameObject in a similar way, like you can already do with the transform :\r\n\r\n    self.gameObject.modelRenderer\r\n\r\n    -- the \"getters/setters as variable\" thing also works on components :\r\n    self.gameObject.mapRenderer.map = \"folder/map name\" -- you can also see here that you can use the map name instead of the map asset\r\n    \r\n    -- writing this same line \"the old way\" takes twice as much characters :\r\n    self.gameObject:GetComponent(\"MapRenderer\"):SetMap(CraftStudio.FindAsset(\"folder/map name\", \"Map\"))\r\n\r\nSet variable or call setters in mass on gameObjects and components.\r\n    \r\n    gameObject:Set({\r\n        parent = \"my parent name\",\r\n\r\n        modelRenderer = {\r\n            model = \"model name\"\r\n        }\r\n\r\n        myScript = {\r\n            health = 100\r\n        }\r\n    })\r\n\r\n\r\nAlso :\r\n\r\n- Use the gameObject or asset name instead of the actual object with some functions\r\n- Simpler raycasting with `ray:InstersectsGameObject()` or `ray:Cast()`\r\n- Triggers (proximity check and interaction with the gameObject in range)\r\n- Easily interact with gameObjects hovered by the mouse\r\n- Events\r\n- Hotkeys (fire events when pressing buttons)\r\n\r\n\r\n## <a id=\"install\"></a>Installation \r\n\r\nDownload then import DaneelFramework.cspack. \r\n\r\nStep by step process :\r\n* Download the file on your computer\r\n* Go to your project's administration, \"Import/Export\" section.  \r\n* Click the import button (top right), navigate to the location you downloaded the pack in then click \"Open\".  \r\n* Navigate to the \"Script\" tab, select all the scripts then click \"Import\".\r\n\r\nThe scripts in the `Daneel/Behaviors` folder must stay in that folder.  \r\nIf you want to use the hotkey events, add the \"Daneel/Behaviors/DaneelInit\" ScriptedBehavior in your scene (all other features works without it).\r\n\r\n\r\n## <a id=\"config\"></a>Configuration\r\n\r\nSome features are only available if a few configuration is done first.\r\nCurrently, all that has to be done is to edit the top of the `DaneelCore` script (just the `Daneel.config` table) and make the list of the scripts (for anything that uses the ScriptedBehaviors) and/or button names (for the hotkey events) of your game.\r\n    \r\n    Daneel.config = {\r\n        -- List of the Scripts paths as values and optionally the script alias as the keys\r\n        scripts = {\r\n            -- \"fully-qualified Script path\"\r\n            -- alias = \"fully-qualified Script path\"\r\n        },\r\n\r\n        -- List of the button names you defined in the \"Administration > Game Controls\" tab of your project\r\n        buttons = {\r\n\r\n        },\r\n\r\n        -- Set to true to enable the framework's advanced debugging features.\r\n        -- Set to false when you ship the game.\r\n        debug = false,\r\n    }\r\n\r\n\r\n## <a id=\"conventions\"></a>Conventions\r\n\r\n* Every getter fonctions are called GetSomething() instead of FindSomething().\r\n* Every object and function names are pascal-cased, except for functions added to Lua's standard libraries which are all lowercase.\r\n* Every time an argument has to be an asset (like with `modelRenderer:SetModel()`), you may pass the fully-qualified asset name instead.\r\n* Every time an argument has to be a gameObject instance (like with `gameObject:SetParent(parentNameOrInstance[, keepLocalTransform])`), you may pass the gameObject name instead.\r\n* Every time an argument has to be an asset or component **type**, you may pass the asset or component **object** instead (ie : `Asset.Get(\"Model name\", ModelRenderer)` instead of `Asset.Get(\"Model name\", \"ModelRenderer\")`). And when you do pass the type as a string, it is case insensitive.\r\n* Every optional boolean arguments default to false.\r\n\r\n\r\n## <a id=\"dynamic_get_set\"></a>Dynamic getters and setters\r\n\r\nGetters and setters functions (functions that begins by Get or Set) may be used on gameOjects and components as if they were variables. Their names must begin by \"Get\" or \"Set\" and have the forth letter uppercase (underscore is allowed). Ie : GetSomething() and Get_something() will works, but Getsomething() or getSomething() won't work.\r\n\r\n    \r\n    self.gameObject.transform.localPosition\r\n    -- is the same as\r\n    self.gameObject.transform:GetLocalPosition()\r\n\r\n    self.gameObject.name = \"a new name\"\r\n    -- is the same as \r\n    self.gameObject:SetName(\"a new name\")\r\n    -- note that only one argument (in addition to the working object) can be passed to the function.\r\n\r\nDynamic getters and setters will also work on your ScriptedBehaviors provided you add their Script's fully-qualified path in `Daneel.config.scripts` :\r\n\r\n    Daneel.config = {\r\n        scripts = {\r\n            \"MyScript\",\r\n            \"folder/MyOtherScript\", \r\n        }\r\n    }\r\n\r\n\r\n## <a id=\"dynamic_components\"></a>Dynamic access to components \r\n\r\nAs Daneel introduce the new `gameObject:GetModelRenderer()`, `gameObject:GetMapRenderer()` and `gameObject:GetCamera()` functions, you may now access any component via its variable, like the transform :\r\n\r\n    self.gameObject.modelRenderer.model = Asset.GetModel(\"model name\") -- Asset.GetModel() is an helper of Asset.Get(), an alias of CraftStudio.FindAsset()\r\n    -- is the same as\r\n    self.gameObject:GetComponent(\"ModelRenderer\"):SetModel(CraftStudio.FindAsset(\"model name\", \"Model\"))\r\n\r\n### ScriptedBehaviors\r\n\r\nScriptedBehaviors may also be accessed this way.  \r\nIt just works right away for those who are not nested in a folder and name is pascal-cased. For instance, with a Script whose name is 'MyScript' :\r\n\r\n    self.gameObject.myScript\r\n    -- is the same as\r\n    self.gameObject:GetScriptedBehavior(CraftStudio.FindAsset(\"MyScript\", \"Script\"))\r\n\r\nScriptedBehaviors who are nested in folders and/or name are not pascal-cased, may be accessed via their aliases as you define them in `Daneel.config.scripts`.\r\n\r\n    -- alias = \"fully-qualified Script path\"\r\n    Daneel.config = {\r\n        scripts = {\r\n            \"MyScript\",\r\n            otherScript = \"folder/my other script\",\r\n        }\r\n    }\r\n\r\n    -- in your script, access the scripteBehavior with its alias :\r\n    self.gameObject.otherScript\r\n\r\n\r\n## <a id=\"mass_setting\"></a>Mass-setting on gameObjects and components\r\n\r\nFunctions `gameObject:Set()` and `component:Set()` accept a \"params\" argument of type table which allow to set variables or call setters in mass.  \r\n\r\n    gameObject:Set({\r\n        parent = \"my parent name\", -- Set the parent via SetParent()\r\n        myScript = {\r\n            health = 100 -- Set the variable health or call SetHealth(100) if it exists on the 'MyScript' scriptedBaheavior \r\n        }\r\n    })\r\n\r\n    modelRenderer:Set({\r\n        localOrientation = Quaternion:New(1,2,3,4), -- set the local orientation via SetLocalOrientation()\r\n        randomVariable = \"random value\"\r\n    })\r\n\r\n\r\n### Component mass-creation and setting on gameObjects\r\n\r\nWith `gameObject:Set()`, you can easily create new components then optionnaly initialize them or set existing components (including ScriptedBehaviors).  \r\n\r\n    gameObject:Set({\r\n        modelRenderer = {\r\n            model = \"Model name\"\r\n        }, -- will create a modelRenderer if it does not yet exists, then set its model\r\n\r\n        camera = {}, -- will create a camera component then do nothing, or just do nothing\r\n\r\n        scriptedBehavior = \"Script name\", -- will create a ScriptedBehavior with the \"Script name\" script if it does not yet exists\r\n        \r\n        scriptedBehaviors = {\r\n            \"script name 2\",\r\n            \"script name 3\", -- will create those ScriptedBehaviors if they don't yet exists\r\n            \r\n            [\"script name 4\"] = {\r\n                variableOrSetter = value\r\n            } -- will create a ScriptedBehavior if it does not yet exists, then set it\r\n        },\r\n\r\n        scriptAlias = {\r\n            variableOrSetter = value\r\n        } -- will set the ScriptedBehavior whose name or alias is 'ScriptAlias'\r\n    })\r\n\r\n\r\n**Components**\r\n\r\nJust set the variable of the same name as the component with the first letter lower case. Set the value as a table of parameters. If the component does not yet exists, it will be created. If you want to create a component without initializing it, just leave the table empty.\r\n\r\nYou can also mass-set existing components on gameObjects via `gameObject:SetComponent()` or its helpers (`gameObject:SetModelRenderer()` and the likes).\r\n    \r\n    self.gameObject:SetMapRenderer({params})\r\n    \r\n    -- or (with the dynamic component getters)\r\n    self.gameObject.mapRenderer:Set({params})\r\n\r\n    -- note that you CAN NOT do the following since the components are cached in the gameObject :\r\n    self.gameObject.mapRenderer = {params}\r\n    -- the variable actually exists on the gameObject, so the dynamic call to Set[ComponentType]() does not work\r\n\r\n**ScriptedBehaviors**\r\n\r\nIf you want to add just one scriptedBehavior, you can set the variable `scriptedBehavior` with the script name or asset as value.  \r\nIf you want to add one or more scriptedBehaviors and maybe initialize them or set existing ScriptedBehaviors, set the variable `scriptedBehaviors` (with an \"s\" at the end) with a table as value.  \r\nThis table may contains the script name or asset of new ScriptedBehaviors as value (if you don't want to initialize them) or the script name or asset as key and the parameters table as value (for new or existing ScriptedBehaviors). Existing ScriptedBehaviors may also be set via their name or alias.\r\n\r\n\r\n## <a id=\"debug\"></a>Debugging\r\n\r\nFor an easy debugging during development, Daneel feature extensive error reporting and a stack trace. Since these features are pretty heavy on function calls, you can turn these on and off (and should disable debug when you ship your game).\r\nIt's turned off by default, so just set the value of the variable `Daneel.config.debug` to `true` to enable it.\r\n\r\nThis affect the functions `Daneel.Debug.CheckArgType()`, `Daneel.Debug.CheckOptionalArgType()`, `Daneel.Debug.PrintError()` plus the functions in `Daneel.Debug.StackTrace`.\r\n\r\n### Error reporting\r\n\r\nEvery arguments are checked for type and value and a comprehensive error message is thrown if needed.  \r\nFor instance, passing false instead of the gameObject's name with `gameObject:GetChild()` would trigger the following error :  \r\n\r\n    GameObject.GetChild(gameObject, name[, recursive]) : Argument 'name' is of type 'boolean' with value 'false' instead of 'string'.\r\n\r\n### Stack Trace\r\n\r\nWhen an error is triggered by `Danel.Debug.PrintError(message)`, Daneel print a \"stack trace\" in the Runtime Report.\r\nThe stack trace nicely shows the history of function calls whithin the framework that lead to the error and display values recieved as argument as well as returned values.  \r\nIt reads from top to bottom, the last function called -where the error occured- at the bottom.  \r\nFor instance, when trying to set the model of a ModelRenderer (to a Model that does not exists) via gameObject:Set() :\r\n\r\n    ~~~~~ Daneel.Debug.StackTrace ~~~~~\r\n    #01 string.ucfirst(\"transform\")\r\n    #02 GameObject.Set(GameObject: 'Object1': 14476932, table: 04DAC148)\r\n    #03 Component.Set(ModelRenderer: 31780825, table: 04DAC238)\r\n    #04 ModelRenderer.SetModel(ModelRenderer: 31780825, \"UnknowModel\")\r\n    [string \"Behavior Daneel/DaneelCore (0)\"]:293: ModelRenderer.SetModel(modelRenderer, modelNameOrAsset) : Argument 'modelNameOrAsset' : model with name 'UnknowModel' was not found.\r\n\r\nNote that the error location will always be in the `DaneelCore` script, just pay attention to the function name in the stack trace to locate the source of the error.\r\n\r\n### Data types\r\n\r\nThe function `Daneel.Debug.GetType(object)` is an extension of Lua's built-in `type()` and may returns any of the built-in Lua types or the name of any of the objects introduced by CraftStudio or Daneel : GameObject, ModelRenderer, MapRenderer, Camera, Transform, Script, Model, ModelAnimation, Map, TileSet, Scene, Sound, Document, Ray, RaycastHit, Vector3, Plane, Quaternion\r\n\r\n\r\n## <a id=\"raycasting\"></a>Raycasting\r\n\r\nGameObjects who have the `CastableGameObject` ScriptedBehavior are known as **castable gameObjects**.  \r\nThe `RaycastHit` object stores the information regarding the collision between a ray and a gameObject. It may contains the keys *distance*, *normal*, *hitBlockLocation*, *adjacentBlockLocation*, *gameObject* and *componentType*.\r\n\r\nThe function `ray:Cast([gameObjects])` cast the ray against all castable gameObjects (or against the provided set of gameObjects) and returns a table of RaycastHit (which will be empty if no gameObjects have been hit).\r\n\r\n\r\n## <a id=\"triggers\"></a>Trigger messages\r\n\r\nGameObjects who have the `TriggerableGameObject` ScriptedBehavior are known as **triggerable gameObjects**. They react when they are near triggers.  \r\nTriggers are gameObjects that perform a spherical proximity check each frames against all triggerable gameObjects.  \r\nTriggers must have the `Trigger` ScriptedBehavior and you must set its `radius` public property.\r\n\r\n* When a triggerable gameObject enters a trigger for the first frame (it is in range this frame, but it wasn't the last frame), the message `OnTriggerEnter` is sent on the gameObject.  \r\n* As long as a gameObject stays under a trigger's radius, the message `OnTriggerStay` is sent on the gameObject (each frame, by each trigger the gameObject is in range of).\r\n* The frame a gameObject leaves the trigger's radius (it is not in range this frame but was in range the last frame), the message `OnTriggerExit` is send on the gameObject.\r\n\r\nEach of these functions receive the trigger gameObject as argument.\r\n\r\n    -- in a ScriptedBehavior attached to a triggerable gameObjects :\r\n    function Behavior:OnTriggerEnter(trigger)\r\n        print(\"The gameObject of name '\"..self.gameObject.name..\"' just reach the trigger of name '\"..trigger.name..\"'.\")\r\n    end\r\n\r\n    function Behavior:OnTriggerStay(trigger)\r\n        if CraftStudio.Input.WasButtonJustRealeased(\"Action\") then\r\n            print(\"The 'Action' button was just released while the gameObject of name '\"..self.gameObject.name..\"' is inside the trigger of name '\"..trigger.name..\"'.\")\r\n        end\r\n    end\r\n    -- a typical use for this is any mechanism that the player can use if he is close enought and press a key\r\n\r\n\r\n## <a id=\"mouse\"></a>Mouse messages\r\n\r\nGameObjects who have the `MousehoverableGameObject` ScriptedBehavior are known as **mousehoverable gameObjects**. They react when they are hovered by the mouse.  \r\nAdd the `CameraMouseOver` ScriptedBehavior to your camera.\r\n\r\n* When a mousehoverable gameObject is hovered for the first frame (it is hovered this frame, but it wasn't the last frame), the message `OnMouseEnter` is sent on the gameObject.\r\n* As long as the mouse stays over the gameObject, the message `OnMouseOver` is sent on the gameObject.\r\n* The frame the mouse stop hovering over a mousehoverable gameObject (it is not hovered this frame but was hovered the last frame), the message `OnMouseExit` is send on the gameObject.\r\n\r\n\r\n## <a id=\"events\"></a>Events\r\n\r\nDaneel provide a event system that allows to run functions or messages on gameObjects whenever some events happens during runtime.\r\n\r\nYou can register global or local functions to be called whenever an event is fired (the function is said to listen to the event).  \r\nAny arguments may be passed to the function when the event is fired.  \r\n    \r\n    local function ALocalFunction(text)\r\n        print(text)\r\n    end\r\n\r\n    function Behavior:Awake()\r\n        Daneel.Event.Listen(\"EventName\", ALocalFunction) -- same for global functions\r\n\r\n        -- to fire an event, just call the Fire() function\r\n        -- and optionally pass the argument(s) after the event name\r\n        Daneel.Event.Fire(\"EventName\", \"Brace for this event !\")\r\n    end\r\n\r\nYou can also make gameObjects to listen to events. By default, the message \"On[Event name]\" will be sent (and optionnaly broadcasted) on that gameObject.  \r\n    \r\n    function Behavior:Awake()\r\n        Daneel.Event.Listen(\"EventName\", self.gameObject) -- the message \"OnEventName\" will be sent on this gameObject only\r\n        Daneel.Event.Listen(\"EventName\", self.gameObject, \"AnotherMessage\") -- the message \"AnotherMessage\" (instead of \"OnEventName\") will be sent on this gameObject only\r\n        Daneel.Event.Listen(\"EventName\", self.gameObject, \"AnotherMessage\", true) -- the message \"AnotherMessage\" will be sent on this gameObject and all of its children\r\n    end\r\n\r\n\r\n## <a id=\"hotkeys\"></a>Hotkeys events\r\n\r\nWhenever you press one of the button whose name is set in `Daneel.config.buttons`, the events nammed `On[Button name]ButtonDown`, `On[Button name]ButtonJustPressed` and `On[Button name]ButtonJustReleased` are fired.\r\n\r\nThe table `Daneel.config.buttons` may be filled with the button names that you defined in the `Administration > Game Controls` tab. Ie :\r\n\r\n    Daneel.config = {\r\n        buttons = {\r\n            -- the list of the button names as they appear in CraftStudio in the \"Game Controls\" tab :\r\n            \"Action\",\r\n            \"fire\",\r\n        }\r\n    }\r\n\r\n\r\n## <a id=\"miscellaneous\"></a>Miscellaneous\r\n\r\n### GameObject\r\n\r\n* Create a gameObject with `GameObject.New()` or `GameObject.Instanciate()`.\r\n* Get a gameObject with `GameObject.Get()` and get a child with `gameObject:GetChild()`.\r\n* Add a component on a gameObject with `gameObject:AddComponent()` or its helpers `gameObject:AddModelRenderer()` and the likes, as well as `gameObject:AddScriptedBehavior()`.\r\n\r\n### Asset \r\n\r\nGet an asset with `Asset.Get()` or its helpers `Asset.GetScript()`, `Asset.GetModel()`, ...\r\n\r\n### Scene\r\n\r\nLoad a scene with `Scene.Load()`, append a scene with `Scene.Append()`.\r\n\r\n### Tables as object\r\n\r\nTables returned by `table.new()` or any new table functions introduced by Daneel that returns a table may be used in an object-oriented way. You can also turn any standard table to such table by passing it as argument to table.new().  \r\n\r\n    -- you always can do this :\r\n    table.insert(myTable, value)\r\n\r\n    -- now, you can also do this (like with strings)\r\n    myTable:insert(value)\r\n\r\nThe `table` object has also been extended with many functions that ease the manipulation of table.\r\n\r\n\r\n## <a id=\"functions_list\"></a>Functions list\r\n\r\n[See the full scripting reference][daneelscriptingreference] for full explanation on arguments and returned values. \r\nArguments between square brackets are optional.\r\n\r\n### Asset\r\n\r\n* Asset.Get(assetName[, assetType])\r\n    * Asset.GetScript(assetName)\r\n    * Asset.GetModel(assetName)\r\n    * Asset.GetModelAnimation(assetName)\r\n    * Asset.GetMap(assetName)\r\n    * Asset.GetTileSet(assetName)\r\n    * Asset.GetScene(assetName)\r\n    * Asset.GetSound(assetName)\r\n\r\n### Component\r\n\r\n* Component.Set(component, params)\r\n* component:Destroy()\r\n\r\n### Daneel.Debug\r\n\r\n* Daneel.Debug.CheckArgType(argument, argumentName, expectArgumentType[, errorHead, errorEnd])\r\n* Daneel.Debug.CheckOptionalArgType(argument, argumentName, expectArgumentType[, errorHead, errorEnd])\r\n* Daneel.Debug.CheckComponentType(componentType)\r\n* Daneel.Debug.CheckAssetType(assetType)\r\n\r\n* Daneel.Debug.GetType(object, getLuaTypeOnly)\r\n* Daneel.Debug.PrintError(message)\r\n* Daneel.Debug.ToRawString(object)\r\n\r\n* Daneel.Debug.StackTrace.BeginFunction(functionName[, ...])\r\n* Daneel.Debug.StackTrace.EndFunction(functionName[, ...])\r\n* Daneel.Debug.StackTrace.Print()\r\n\r\n### Daneel.Events\r\n\r\n* Daneel.Events.Listen(eventName, function) / Daneel.Events.Listen(eventName, gameObject[, functionName, broadcast])\r\n* Daneel.Events.StopListen(eventName, functionOrGameObject)\r\n* Daneel.Events.Fire(eventName[, ...])\r\n\r\n### Daneel.Utilities\r\n\r\n* Daneel.Utilities.CaseProof(name, set)\r\n\r\n### GameObject\r\n\r\n* GameObject.New(name[, params])\r\n* GameObject.Instanciate(name, sceneNameOrObject[, params])\r\n* GameObject.Get(name)\r\n\r\n* gameObject:SetParent(parentNameOrInstance[, keepLocalTransform])\r\n* gameObject:GetChild(childName[, recursive])\r\n* gameObject:GetChildren([recursive, includeSelf])\r\n* gameObject:SendMessage(functionName[, data])\r\n* gameObject:BroadcastMessage(functionName[, data])\r\n\r\n* gameObject:AddComponent(componentType[, params]) / gameObject:AddComponent(\"ScriptedBehavior\", scriptNameorAsset[, params])\r\n    * gameObject:AddScriptedBehavior(scriptNameOrAsset[, params])\r\n    * gameObject:AddModelRenderer([params])\r\n    * gameObject:AddMapRenderer([params])\r\n    * gameObject:AddCamera([params])\r\n\r\n* gameObject:SetComponent(componentType, params) / gameObject:SetComponent(\"ScriptedBehavior\", scriptNameorAsset, params)\r\n    * gameObject:SetScriptedBehavior(scriptNameOrAsset, params)\r\n    * gameObject:SetModelRenderer(params)\r\n    * gameObject:SetMapRenderer(params)\r\n    * gameObject:SetCamera(params)\r\n    * gameObject:SetTransform(params)\r\n\r\n* gameObject:GetComponent(componentType[, scriptNameOrAsset])\r\n    * gameObject:GetScriptedBehavior(scriptNameOrAsset)\r\n    * gameObject:GetModelRenderer()\r\n    * gameObject:GetMapRenderer()\r\n    * gameObject:GetCamera()\r\n\r\n* gameObject:Destroy()\r\n\r\n### math\r\n\r\n* math.isinteger(value[, strict])\r\n\r\n### MapRenderer\r\n\r\n* mapRenderer:SetMap(mapNameOrAsset[, keepTileSet])\r\n* mapRenderer:SetTileSet(tileSetNameOrAsset)\r\n\r\n### ModelRenderer\r\n\r\n* modelRenderer:SetModel(modelNameOrAsset)\r\n* modelRenderer:SetAnimation(animationNameOrAsset)\r\n\r\n### Ray\r\n\r\n* ray:Cast([gameObjects])\r\n* ray:IntersectsGameObject(gameObjectNameOrInstance)\r\n\r\n### RaycastHit\r\n\r\n* RaycastHit.New([distance, normal, hitBlockLocation, adjacentBlockLocation, gameObject])\r\n\r\n### Scene\r\n\r\n* Scene.Load(sceneNameOrAsset)\r\n* Scene.Append(sceneNameOrAsset, gameObjectNameOrInstance)\r\n\r\n### string\r\n\r\n* string.totable(string)\r\n* string.isoneof(string, set[, ignoreCase])\r\n* string.ucfirst(string)\r\n\r\n### table\r\n\r\n* table.new([table])\r\n* table.copy(table)\r\n* table.constainskey(table, key)\r\n* table.constainsvalue(table, value[, ignoreCase])\r\n* table.length(table[, keyType])\r\n* table.print(table)\r\n* table.printmetatable(table)\r\n* table.merge(...)\r\n* table.compare(table1, table2)\r\n* table.combine(keys, values[, strict])\r\n* table.removevalue(table, value[, singleRemove])\r\n* table.getkeys(table)\r\n* table.getvalues(table)\r\n* table.getkey(table, value)\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}