==========
IDEAS

    -----
    MISC

    - modelRenderer:SetDimension(Vector3) ou idem avec Vector2

    - textRenderer
        - permettre de passer texte traduit via la scène : "daneellang:langkey"
            > TextRenderer.Settext n'est pas utilisée lorsque les textes sont écrits dans la scène
            mais voir à créer un ScriptedBehavior qui irait remplacer le texte "Lang" behavior

    - possibilité de enable/disable un gameObject ou un component
        > empèhe les composants de GUI d'être mis à jour
        > ideallement devrait être géré par CS directement au niveau du game object

    - Debug.DrawLine(start, end[, model]) ou (start, direction, length[, model])
        Daneel.Config.debug.defaultLineModel
        DrawCircle( position, radius, nbofsegment, model )


    -----
    GUI

    - Input
        - curseur et tout ce qui va avec
    
    - "progress bar" mais avec plusieurs éléments
    lorsque élément pas utilisé, il a opacity, scale etc au choix dans la config, donc
      out et in state  

    - scrollable windows : 
        n'affiche que ce qui est dans une certaine zone
        déplacement via slider (assenseur) ou molette souris
        introduit object Rect( x, y, width, height )

        scale à 0 les objects en dehors de la fenètre
        > ou les cache avec un autre model par exemple
        > ou les fenètres sont rendue par d'autres cameras dont l'object Rect
    
    -----
    TWEEN

    - tweener
        permettre de tweener en même temps plusieurs valeur/propriétés
        garder les tweeners agissant sur un GO ou composant sur une propriété gameObject.tweeners


    - Timeline
        table de tweeners. clés = temps, valeur = tweeners
        fait débuter les tweeners en fonction du temps
        fonction : Play, Pause, Restart, Complete, Destroy, Update

    - stack de tweeners qui débutent les uns après les autres
        réécrire la fonction OnComplete pour lancer le prochain tweener (timeline:StartNext())
        propriété current qui point vers le tweenr courant

    - commaun au stack et tweeners : 


    -----
    MODULE / PLUGIN / EXTENSION

    - module = notion abstraite (n'est pas limitée à un object ou un fichier), qui possède ou non les fonctions DaneelModule[Module]Config(), DaneelModule[Module]Load, ..Awake, ..Start, ..Update
    - permettre dépendances (un module oblige d'autre à se charger aussi)
        > module étent la config et ajoute les modules dont il dépend qui sont ajoutés avant lui dans la table des modules à charger
    - liste des modules chargés + empècher plusieurs chargements du même modules


    -----
    PARTICLE EMITTER
    > gameObject composant

    "similaire" au tweeners, dépend des tweener

    propriétés
    - isPaused, isEnabled, hasStarted, isCompleted
    - loops, completedLoops 
    - delay
    - elapsed, fullElapsed
    
    - duration 
    - durationType
    - emitionRate (nb particle per durationType) > calcule maxParticleCount si nil
    - maxParticleCount (nb of particles emitted over the duration) > calcule emitionRate si nil
    
    - createParticleFromScene > 
        set the state of the emitted particles
        gameObject émits peuvent être issue d'une scène et/ou sont modifié par paramètres :
    
    - particleStartParams
        - Lifetime > nil or < 1 for infinite life (in durationType unit)
        - any component property


    Events :
    - OnStart, OnPause, OnPlay, OnComplete, OnLoopComplete,
    - OnNewParticle sur le GO qui emet la particle et sur le gameObject émit
    - OnParticleDie when lifetime is over > pourquoi pas utiliser OnDestroy ?

    Function :
    Pause, Play, Restart, Destroy
    

    ------
    Frustrum Culling

    - For each camera, create a "CullingMask" gameObject with a modelRenderer sized to the camera's viewport

    gamObject:IsVisibleFromCamera( camera GO or component ) returns true or false, or nil if no culling mask is set
    camera:GetVisibleGameObjects( tags ) returns the list of the gameObjects that are visible from the camera 

    FrustrumCulling scripted behavior
    public properties :
    tags
    cullingInterval 

    Fires the following events when they leave/enter the frustrum
    OnBecomeVisible( cameraGO )     (OnCameraEnter)
    OnBecomeInvisible( cameraGO )   (OnCameraExit)

    Enable to set a near and far plane

    
    ------
    Occlusion Culling

    Create a grid of rays based of the screen size in pixel.
    For each rays, keep the closest gameObject 
    Only render the closest GO
    Enable to set a near and far plane


    ------
    Squared triggers

    make the trigger create a ray from the checked GO and the trigger
    if the ray hit, that's because the GO was outside of the trigger's model
    if the ray don't hit, that's because the GO is inside the trigger's model, so he is in the 

    Enable this on regular triggers when the 'BoxTrigger' property is true (disable the range altogether)
    Allow to use a map or textRenderer instead of a modelRenderer



==========
A implémenter
    
    
    - argument checkInterval sur MouseInput


==========
A tester

    - voir pourquoi certains easeType renvoient des erreurs
    - getscriptedbehavior avec string qui ne sont pas des scripts
    - suppression d'un gameObject mais l'un de ses composant (détruit) avec lui est encore enregistré pour certains events
    - GO.GetwithTag()


==========
A modifier/ajouter dans la doc :

    - Example project : minimalist encounter


=========
BUGS

    -- ajouter un TextArea via le scripted behavior renvoie l'exception :

    - parfois, une ligne de la stacktrace n'est pas complète : #04 GameObject.Ge)
        > quadn argument attendus est nil ?


OLD

    - utiliser Awake au lieu de start dans CheckBox, et créer une checkBox via le ScriptedBehavior envoie un exception

    > créer le scriptedBehavior de la checkBox depuis CheckBox.New() lorsqu'il existait déjà renvoie cette exception

    Exception non gérée : System.InvalidOperationException: La collection a été modifiée ; l'opération d'énumération peut ne pas s'exécuter.


=========

ordre chargement des fichiers :
- dans l'ordre de création (id d'asset croissant)
- dernier script modifié sans faire de révision depuis le dernier export est chargé en premier

