==========
IDEAS

    -----
    MISC


    - DEBUG
        - introduire un CheckArgValue, CheckOptionalArgValue > remplace CheckAssetType(), CheckComponentType()
  
    - modelRenderer:SetDimension(Vector3) ou idem avec Vector2

    - revoir l'utilisation de error(), print() et de la stacktrace
        lorsque debug activé, la localisation des erreurs se trouve toujours dans dans Daneel

        il faut que error() utiliser dans n'importe quel fichier puisse afficher la stacktrace > pas possible sans la réécrire

        CheckArgType() va toujours retourner l'erreur depuis Daneel.lua, mais on a le nom de la fonction impliquée

        Debug.Beginfunction("function name", {
            {
                name = "argumentName",
                value = argValue,
                expectedType = Type, > appel CheckArgType
                expectedValue = Values, > appel auto CheckValue ou checkDefault Value
                defaultValue = "machin" > si expectedType or Value sont définits, fait appeler la version "optional" des fonctions
            },

            minimun info = argValue
        })
        > cette fonction enregistre la stacktrace
        et fait appeler Debug.Check.. en fonction des valeurs trouvées

    - GameObject : permettre de chainer des GameObject.Get() et GameObject.GetChild() en séparents plusieurs nom de GO par un point
    ie : GameObject.Get("Menu.Lang.French")     gameObject:GetChild("Lang.French")
    > permet d'obtenir facilement des GO dont le nom n'est pas unique
    
    - textRenderer
        - permettre de définir un font et aligment par défaut (pour n'importe quel component)
        - permettre de facilement sauter des lignes (avec :br:) ou définir un wordWrap ?? > nécessite plusieurs GO et composants
        - permettre de féfinir l'alignement avec simplement "left", "right", "center"
        
    
    -----
    GUI

    - Input
        - curseur et tout ce qui va avec
    
    - "progress bar" mais avec plusieurs éléments
    lorsque élément pas utilisé, il a opacity, scale etc au choix dans la config, donc
      out et in state  

    
    -----
    TWEEN

    - tweener
        permettre de tweener en même temps plusieurs valeur/propriétés

    - Timeline
        table de tweeners. clés = temps, valeur = tweeners
        fait débuter les tweeners en fonction du temps
        fonction : Play, Pause, Restart, Complete, Destroy, Update

    - stack de tweeners qui débutent les uns après les autres
        réécrire la fonction OnComplete pour lancer le prochain tweener (timeline:StartNext())
        propriété current qui point vers le tweenr courant

    - commaun au stack et tweeners : 


    -----
    MODULE / PLUGIN / EXTENSION

    - voir plus en profondeur comment Composer (php), node.js font pour gérer ça
    - module = un object global, sur lequel existe ou non les fonctions Config, Load, Awake, Start, Update
    - permettre dépendances (un module oblige d'autre à se charger aussi)
    - liste des modules chargés + empècher plusieurs chargements du même modules


==========
A implémenter

    -----
    DEVELOP   

    -----
    GUI
   
    -----
    TWEENER


==========
A tester

    - voir pourquoi certains easeType renvoient des erreurs

    - arg data de OnNewComponent is nil when component is scriptedBehavior (ou au moins checkbox)

    - créer Behavior depuis un Awake de Behavior


==========
A modifier/ajouter dans la doc :

    - Example project : minimalist encounter


=========
BUGS

    - parfois, une ligne de la stacktrace n'est pas complète : #04 GameObject.Ge)
        > quadn argument attendus est nil ?


OLD

    - utiliser Awake au lieu de start dans CheckBox, et créer une checkBox via le ScriptedBehavior envoie un exception

    > créer le scriptedBehavior de la checkBox depuis CheckBox.New() lorsqu'il existait déjà renvoie cette exception

    Exception non gérée : System.InvalidOperationException: La collection a été modifiée ; l'opération d'énumération peut ne pas s'exécuter.


=========

ordre chargement des fichiers :
- dans l'ordre de création (id d'asset croissant)
- dernier script modifié sans faire de révision depuis le dernier export est chargé en premier




