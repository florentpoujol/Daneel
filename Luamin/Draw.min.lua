Draw={}Daneel.modules.Draw=Draw;local a={}local b="string"local c="boolean"local d="number"local e="table"local f="Vector3"local g={"gameObject","GameObject"}local h={"params",e,defaultValue={}}local i={"line","LineRenderer"}local j={"circle","CircleRenderer"}local k={"draw",c,defaultValue=true}Draw.LineRenderer={}a["Draw.LineRenderer.New"]={g,h}function Draw.LineRenderer.New(l,m)local n={origin=l.transform:GetPosition(),_direction=Vector3:Left(),_length=1,_width=1,gameObject=l}n._endPosition=n.origin;l.lineRenderer=n;setmetatable(n,Draw.LineRenderer)m=table.merge(Draw.Config.lineRenderer,m)if m.endPosition~=nil then m.length=nil;m.direction=nil end;n:Set(m)return n end;a["Draw.LineRenderer.Set"]={i,h}function Draw.LineRenderer.Set(n,m)if m.endPosition then if m.length or m.direction then if Daneel.Config.debug.enableDebug then local o="Draw.LineRenderer.Set( line, params ) : The 'endPosition' property is set with value "..tostring(m.endPosition)if m.length then o=o.." The 'length' property with value '"..tostring(m.length).."' has been ignored."end;if m.direction then o=o.." The 'direction' property with value '"..tostring(m.direction).."' has been ignored."end;print(o)end;m.length=nil;m.direction=nil end end;local draw=false;for p,q in pairs(m)do local r="Set"..string.ucfirst(p)if Draw.LineRenderer[r]~=nil then draw=true;if r=="SetDirection"then Draw.LineRenderer[r](n,q,nil,false)else Draw.LineRenderer[r](n,q,false)end else n[p]=q end end;if draw then n:Draw()end end;a["Draw.LineRenderer.Draw"]={i}function Draw.LineRenderer.Draw(n)n.gameObject.transform:LookAt(n._endPosition)n.gameObject.transform:SetLocalScale(Vector3:New(n._width,n._width,n._length))Daneel.Event.Fire(n,"OnDraw",n)end;a["Draw.LineRenderer.SetEndPosition"]={i,{"endPosition",f},k}function Draw.LineRenderer.SetEndPosition(n,s,draw)n._endPosition=s;n._direction=n._endPosition-n.origin;n._length=n._direction:Length()if draw==nil or draw then n:Draw()end end;a["Draw.LineRenderer.GetEndPosition"]={i}function Draw.LineRenderer.GetEndPosition(n)return n._endPosition end;a["Draw.LineRenderer.SetLength"]={i,{"length",d},k}function Draw.LineRenderer.SetLength(n,t,draw)n._length=t;n._endPosition=n.origin+n._direction*t;if draw==nil or draw then n:Draw()end end;a["Draw.LineRenderer.GetLength"]={i}function Draw.LineRenderer.GetLength(n)return n._length end;a["Draw.LineRenderer.SetWidth"]={i,{"direction",f},{"useDirectionAsLength",c,defaultValue=false},k}function Draw.LineRenderer.SetDirection(n,u,v,draw)n._direction=u:Normalized()if v then n._length=u:Length()end;n._endPosition=n.origin+n._direction*n._length;if draw==nil or draw then n:Draw()end end;a["Draw.LineRenderer.GetDirection"]={i}function Draw.LineRenderer.GetDirection(n)return n._direction end;a["Draw.LineRenderer.SetWidth"]={i,{"width",d},k}function Draw.LineRenderer.SetWidth(n,w,draw)n._width=w;if draw==nil or draw then n:Draw()end end;a["Draw.LineRenderer.GetWidth"]={i}function Draw.LineRenderer.GetWidth(n)return n._width end;Draw.CircleRenderer={}a["Draw.CircleRenderer.New"]={g,h}function Draw.CircleRenderer.New(l,m)local x={gameObject=l,origin=l.transform:GetPosition(),segments={},_segmentCount=6,_radius=1,_width=1,_model=nil}x._endPosition=x.origin;l.circleRenderer=x;if m.model==nil and l.modelRenderer~=nil then m.model=l.modelRenderer:GetModel()l.modelRenderer:SetModel(nil)end;setmetatable(x,Draw.CircleRenderer)x:Set(table.merge(Draw.Config.circleRenderer,m))return x end;a["Draw.CircleRenderer.Set"]={j,h}function Draw.CircleRenderer.Set(x,m)local draw=false;for p,q in pairs(m)do local r="Set"..string.ucfirst(p)if Draw.CircleRenderer[r]~=nil then draw=true;Draw.CircleRenderer[r](x,q,false)else x[p]=q end end;if draw then x:Draw()end end;a["Draw.CircleRenderer.Draw"]={j}function Draw.CircleRenderer.Draw(x)local y=2*math.pi/x._segmentCount;local z=-y;local A=x:GetId()for B=1,x._segmentCount do z=z+y;local C=Vector3:New(x._radius*math.cos(z),x._radius*math.sin(z),0)if x.segments[B]==nil then local D=CS.CreateGameObject("Circle "..A.." Segment "..B,x.gameObject)D:CreateComponent("ModelRenderer")if x._model~=nil then D.modelRenderer:SetModel(x._model)end;table.insert(x.segments,B,D)end;x.segments[B].transform:SetLocalPosition(C)end;while#x.segments>x._segmentCount do table.remove(x.segments):Destroy()end;local E=x.segments[1].transform:GetPosition()local F=Vector3.Distance(E,x.segments[2].transform:GetPosition())for B,G in ipairs(x.segments)do if x.segments[B+1]~=nil then G.transform:LookAt(x.segments[B+1].transform:GetPosition())else G.transform:LookAt(E)end;G.transform:SetLocalScale(Vector3:New(x._width,x._width,F))end;Daneel.Event.Fire(x,"OnDraw",x)end;a["Draw.CircleRenderer.SetRadius"]={j,{"radius",d},k}function Draw.CircleRenderer.SetRadius(x,H,draw)x._radius=H;if draw==nil or draw then x:Draw()end end;a["Draw.CircleRenderer.GetRadius"]={j}function Draw.CircleRenderer.GetRadius(x)return x._radius end;a["Draw.CircleRenderer.SetSegmentCount"]={j,{"count",d},k}function Draw.CircleRenderer.SetSegmentCount(x,I,draw)if I<3 then I=3 end;if x._segmentCount~=I then x._segmentCount=I;if draw==nil or draw then x:Draw()end end end;a["Draw.CircleRenderer.GetSegmentCount"]={j}function Draw.CircleRenderer.GetSegmentCount(x)return x._segmentCount end;a["Draw.CircleRenderer.SetWidth"]={j,{"width",d}}function Draw.CircleRenderer.SetWidth(x,w)if x._width~=w then x._width=w;if#x.segments>0 and draw then local J=Vector3:New(x._width,x._width,x.segments[1].transform:GetLocalScale().z)for B,n in pairs(x.segments)do n.transform:SetLocalScale(J)end end end end;a["Draw.CircleRenderer.GetWidth"]={j}function Draw.CircleRenderer.GetWidth(x)return x._width end;a["Draw.CircleRenderer.SetModel"]={j,{"model",{"string","Model"},isOptional=true}}function Draw.CircleRenderer.SetModel(x,K)if x._model~=K then if type(K)=="sting"and x._model~=nil and x._model:GetPath()==K then return end;if K~=nil then x._model=Asset.Get(K,"Model",true)else x._model=nil end;for B,n in pairs(x.segments)do n.modelRenderer:SetModel(x._model)end end end;a["Draw.CircleRenderer.GetModel"]={j}function Draw.CircleRenderer.GetModel(x)return x._model end;a["Draw.CircleRenderer.SetOpacity"]={j,{"opacity","number"}}function Draw.CircleRenderer.SetOpacity(x,L)for B=1,#cicle.segments do x.segments[B].modelRenderer:SetOpacity(L)end end;a["Draw.CircleRenderer.GetOpacity"]={j}function Draw.CircleRenderer.GetOpacity(x)if x.segments[1]~=nil then return x.segments[1].modelRenderer:GetOpacity()end;return nil end;table.mergein(Daneel.functionsDebugInfo,a)function Draw.DefaultConfig()local M={lineRenderer={direction=Vector3:Left(),length=2,width=0.1},circleRenderer={segmentCount=6,radius=1,width=1,model=nil},componentObjects={LineRenderer=Draw.LineRenderer,CircleRenderer=Draw.CircleRenderer},propertiesByComponentName={lineRenderer={"length","endPosition","direction","width"},circleRenderer={"radius","segmentCount","direction","width","opacity"}}}return M end;Draw.Config=Draw.DefaultConfig()function Draw.Load()if Daneel.modules.Tween then table.mergein(Tween.Config.propertiesByComponentName,Draw.Config.propertiesByComponentName)end end