
-- Bc : Back color
-- Fc : Front color
-- Fo : Front opacity (back opacity is always 1)
-- Rc : Result color, the one we see

-- Relations :
-- Bc = ( Fc * Fo - Rc ) / ( Fo - 1 )
-- Fc = ( Rc - Bc ) / Fo + Bc
-- Fo = ( Rc - Bc ) / ( Fc - Bc )
-- Rc = ( Fc - Bc ) * Fo + Bc

-- if Bc = 0 then Rc = 255 * Fo
-- if Bc = 255 then Rc = Fc

-- With a set of 6 predetermined colors Red, Green, Blue, Magenta, Cyan, Yellow
-- We can create 2295 (255*2*3+255*3) colors

-- The generator can create colors where :
-- One of the component is equal to 0 or 255 and the other components are apart and equidistant from 128
-- ie : (255, 50, 200) (128, 0, 128) (170, 85, 0)
-- or
-- Two components are equal and the third one is apart and equidistant from 128
-- ie : (153, 102, 153) (51, 51, 204)


-- circle : one comp = 0, other are equidistant
-- hexagon : cyan-magenta-yellow = one comp = 255, others are equidistant
-- calque 3 :    two color equal, other equidistant
-- star : one or two at 255, othe is moving    only saturation is moving


-- white model change the saturation    opa = 0.5 > sat =      opa = 0.3  sat = 70
-- black model change   opa = 0.3 sat = 

-- sat = 0   > rgb coords goes toward the highmost coords
-- sat correspond to the smallest component value
-- sat = 100 - lowest comp / highest comp * 100

-- value = 0   > rgb coords goes toward the smallest coords
-- value correspond to the smallest component value


ColorGenerator = {}
Daneel.modules.ColorGenerator = ColorGenerator

ColorGenerator.DefaultConfig = {
    modelPathsByColor = {},
    modelsByColor = {}
}

ColorGenerator.Config = table.copy( ColorGenerator.DefaultConfig )

function ColorGenerator.Load()
    local colors = {"Red", "Green", "Blue", "Yellow", "Cyan", "Magenta", "White", "Black"}
    for i, color in pairs( colors ) do
        local path = ColorGenerator.Config.modelPathsByColor[ color ]
        if path == nil then
            path = "Colors/"..color
        end
        if path ~= nil then
            ColorGenerator.Config.modelsByColor[ color ] = Asset.Get( path, "Model", true )
        else
            print("ColorGenerator.Load(): missing path for model of color "..color.." in config.")
        end
    end
end

function ModelRenderer.SetColor( modelRenderer, r, g, b )
    local Bc, Fc, Fo, Sc, So = ColorGenerator.RGB( r, g, b )
    
    --
    local backRndr = modelRenderer
    backRndr:SetModel( ColorGenerator.Config.modelsByColor[ Bc ] )

    --
    local frontRndr = modelRenderer.gameObject.modelRenderer2
    if frontRndr == nil then
        frontRndr = modelRenderer.gameObject:CreateComponent("ModelRenderer")
        modelRenderer.gameObject.modelRenderer = backRndr
        modelRenderer.gameObject.modelRenderer2 = frontRndr
    end

    frontRndr:SetModel( ColorGenerator.Config.modelsByColor[ Fc ] )
    frontRndr:SetOpacity( Fo )

    --
    local modRndr = modelRenderer.gameObject.modelRenderer3 -- modifier (saturation/value) (white/black)
    if Sc ~= nil then
        if modRndr == nil then
            modRndr = modelRenderer.gameObject:CreateComponent("ModelRenderer")
            modelRenderer.gameObject.modelRenderer = backRndr
            modelRenderer.gameObject.modelRenderer3 = modRndr
        end

        modRndr:SetModel( ColorGenerator.Config.modelsByColor[ Sc ] )
        modRndr:SetOpacity( So )
    elseif modRndr ~= nil then
        modRndr:SetOpacity(0)
    end
end




function ColorGenerator.RGB(red, green, blue)
    local Bc = Color.New(0)
    local Fc = Color.New(0)
    local Fo = 1.0

    local Ic = Color.New(red, green, blue) -- intermediate color (result of the front and back colors)
        
    local Mc = Color.New(0) -- modifier color
    local Mo = 0 --  modifier opacity

    local Rc = Color.New(red, green, blue) -- Result color
    
    local RComp = nil -- remarquable component ("r", "g", or "b", not a game object's component)
    

    local function getOpacity(Bc, Fc, Rc) -- args are of type numbers
        return math.round( (Rc - Bc) / (Fc - Bc), 3 )
    end


    local function GetModifierInfo( Rc, RComp, Ic, Mc, Mo)
    
        local mean = ((Rc.r + Rc.g + Rc.b - Rc[RComp]) / 2)
        if Rc[RComp] == 255 then
            Mc = Color.white
        else
            Mc = Color.black
        end
            
        if 
            (Rc[RComp] == 255 and mean > 127.5)
            or
            (Rc[RComp] == 0 and mean < 127.5)            
        then
            
            
            -- calculate Ic
                -- calculate color that must be generated by the back and front models
                local lowestCompValue = 256
                for comp, value in pairs( Rc:ToRGB() ) do
                    if comp ~= RComp and lowestCompValue > value then
                        lowestCompValue = value
                    end
                end 
                -- can't use math.min( Rc.r, Rc.g, Rc.b ) because don't work when Rc[RComp] == 0
    
                -- calculate offset of the component's values from the mean
                local offsetFromMean = mean - lowestCompValue
    
                -- calculate offset of the component's values from the mean
                -- by unit of mean from 255 or 0
                local unitOffset = offsetFromMean / math.abs( Rc[RComp] - mean )
                -- denominator is 
                -- (255 - mean) when Rc[RComp] == 255
                -- (mean)       when Rc[RComp] == 0               
    
                -- calculate new offset at mean = 128
                local newOffset = unitOffset * 128
    
                -- calculate new component values at mean = 128
                local newHighestCompValue = 128 + newOffset
                local newLowestCompValue = 128 - newOffset
                
                -- adjust Ic with these new values
                for comp, value in pairs( Ic:ToRGB() ) do
                    if comp ~= RComp then
                        if value > mean then
                            Ic[comp] = newHighestCompValue
                        else
                            Ic[comp] = newLowestCompValue
                        end
                    end
                end
                  
            -- calculate the color saturation
            if Rc[RComp] == 255 then
                local RcSat = Rc:GetSaturation()
                local IcSat = Ic:GetSaturation()
                if RcSat > IcSat then
                    print("error, color system can't display this color", RcSat, IcSat)
                end
            else
                local RcValue = Rc:GetValue()
                local IcValue = Ic:GetValue()
                if RcValue > IcValue then
                    print("error, color system can't display this color", RcSat, IcSat)
                end
            end

            local _Bc = Ic.r
            local _Fc = Mc.r
            local _Rc = Rc.r
            if RComp == "r" then
                _Bc = Ic.g
                _Fc = Mc.g
                _Rc = Rc.g
            end
            print( "Mo", _Bc, _Fc, _Rc )
            Mo = getOpacity( _Bc, _Fc, _Rc )
        else
            print("error 2, color system can't display this color", mean, Rc)
        end
        
        print("modifier info:", Ic, Mc, Mo)
        return Ic, Mc, Mo
    end


    --


    RComp = Rc:GetFirstComponentEqualTo(0)
    if RComp ~= nil then
        Bc[RComp] = 0
        Fc[RComp] = 0
    else
        RComp = Rc:GetFirstComponentEqualTo(255)
        Bc[RComp] = 255
        Fc[RComp] = 255
    end


    -- need the modifier
    Ic, Mc, Mo = GetModifierInfo( Rc, RComp, Ic, Mc, Mo )
    
    if RComp == "r" then
        Bc.g = 255
        Bc.b = 0
        -- Yellow

        Fc.g = 0
        Fc.b = 255
        -- Magenta

        Fo = getOpacity(255, 0, Ic.g)

    elseif RComp == "g" then
        Bc.r = 255
        Bc.b = 0
        -- Yellow

        Fc.r = 0
        Fc.b = 255
        -- Cyan

        Fo = getOpacity(255, 0, Ic.r)

    elseif RComp == "b" then
        Bc.r = 255
        Bc.g = 0
        -- Magenta

        Fc.r = 0
        Fc.g = 255
        -- Cyan

        Fo = getOpacity(255, 0, Ic.r)
    end
    
    --end 
    
    Bc = Bc:GetName()
    Fc = Fc:GetName()
    Mc = Mc:GetName()


    print(Bc, Fc, Fo, Mc, Mo)

    -- returns the names of the models to use, and the front opacity
    return Bc, Fc, Fo, Mc, Mo
end


----------------------------------------------------------------------------------
-- Color

ColorMT = {}
Color = {}
setmetatable(Color, ColorMT)




function Color.__tostring(color)
    return "Color: { r="..color._r..", g="..color._g..", b="..color._b.." }"
end

Color.colorsByName = {
    red = {255,0,0},
    green = {0,255,0},
    blue = {0,0,255},

    yellow = {255,255,0},
    cyan = {0,255,255},
    magenta = {255,0,255},

    white = {255,255,255},
    black = {0,0,0},
    gray = {50,50,50},
    grey = {50,50,50}, -- English spelling
}
Color.colorNames = table.getkeys( Color.colorsByName )
-- TODO : make colorNames be updated from a module Load() so that people can extend Color.colorsByName

function ColorMT.__index( object, key )
    if table.containsvalue( Color.colorNames, key ) then
        -- allow to get new Color instance by writing "Color.blue"
        return Color.New( Color.colorsByName[ key ] )
    end
end

function Color.__index( color, key )
    if Color[ key ] ~= nil then
        return Color[ key ]
    end

    if key == 1 or key == 2 or key == 3 then
        local comps = {"r", "g", "b"}
        key = comps[key]
    end

    if key == "r" or key == "g" or key == "b" then
        return color[ "_"..key ]

    end

    return rawget( color, key )
end

function Color.__newindex( color, key, value )
    if key == 1 or key == 2 or key == 3 then
        local comps = {"r", "g", "b"}
        key = comps[key]
    end

    if key == "r" or key == "g" or key == "b" then
        color["_"..key] = math.round( math.clamp( tonumber( value ), 0, 255 ) )
    else
        rawset( color, key, value )
    end
end

--- Create a new color.
-- @param r (number, Color, table or Vector3) The Red component of the color or a table with r,g,b / x,y,z / 1,2,3 components.
-- @param g (number) [optional] The green component of the color.
-- @param b (number) [optional] The blue component of the color.
-- @return (Color) The color.
function Color.New(r, g, b)
    if type( r ) == "table" then
        if r.r ~= nil then -- Color style
            g = r.g
            b = r.b
            r = r.r
        elseif r.x ~= nil then -- Vector3 style
            g = r.y
            b = r.z
            r = r.x
        elseif #r == 3 then -- array style
            g = r[2]
            b = r[3]
            r = r[1]
        end
    end

    local color = setmetatable({}, Color)
    color.r = r or 0
    color.g = g or color.r
    color.b = b or color.g

    return color
end

--- Return the name of first component (in the r,g,b order) that has the provided value.
-- @param color (Color) The color.
-- @param value (number) The value to search in the color's components.
-- @return (string) The component name or nil.
function Color.GetFirstComponentEqualTo(color, value) -- IsOneComponentEqualTo
    for i, component in ipairs({"r", "g", "b"}) do
        if value == color[ component ] then
            return component
        end
    end
    return nil
end

--- Tell whether at least two components have the same value.
-- @param color (Color) The color.
-- @return (boolean) True if at least two components have the same value, or false.
function Color.AreTwoComponentsEqual(color)
    if color.r == color.g or color.r == color.b or color.g == color.b then
        return true
    end
    return false
end

--- Return the name of the component that has not the same value as the two others (which are equal).
-- @param color (Color) The color.
-- @return (string) The component's name.
function Color.GetLoneComponent(color)
    if color.r == color.g then
        if color.r == color.b then
            return nil
        end
        return "b"
    elseif color.r == color.b then
        return "g"
    elseif color.g == color.b then
        return "r"
    end
    return nil
end


function Color.ToArray( color )
    return { color.r, color.g, color.b }
end
function Color.GetArray( color )
    return Color.ToArray( color )
end

function Color.ToRGB( color )
    return { r = color.r, g = color.g, b = color.b }
end
function Color.GetRgb( color ) -- just so that we can write  Color.rgb
    return color:ToRGB()
end


function Color.GetHex( color, suffix )
    return Color.RGBToHex( color._r, color._g, color._b, suffix )
end
function Color.SetHex( color )
    local rgb = { Color.HexToRGB( color, nil, nil, "" ) }
    local comps = { "r", "g", "b" }
    for i, value in ipairs( rgb ) do
        color[ comps[i] ] = value
    end
end



-- Convert an hexadecimal color into its RGB components.
-- @param hex (string) The hexadecimal color. May be prefixed by "#", "0x", "0X" or nothing
-- @return (number) The color's red component.
-- @return (number) The color's green component.
-- @return (number) The color's blue component.
function Color.HexToRGB( hex )
    -- from : https://gist.github.com/jasonbradley/4357406
    hex = hex:gsub("#",""):gsub("0x",""):gsub("0X","")
    return tonumber("0x"..hex:sub(1,2)), tonumber("0x"..hex:sub(3,4)), tonumber("0x"..hex:sub(5,6))
end

-- passing a table like {255, 100, 20}
-- same args as 
function Color.RGBToHex( r, g, b, suffix )
    -- from : https://gist.github.com/marceloCodget/3862929
    if type( r ) == "table" and type( g ) == "string" and suffix == nil then
        suffix = g
        g = nil
        b = nil
    end
    
    local colorArray = Color.New( r, g, b ):ToArray()
    local hexadecimal = suffix or ""
     
    for key, value in ipairs(colorArray) do
        local hex = ''
        
        while value > 0 do
            local index = math.fmod(value, 16) + 1
            value = math.floor(value / 16)
            hex = string.sub('0123456789ABCDEF', index, index) .. hex   
        end
         
        if string.len(hex) == 0 then
            hex = '00'
        elseif string.len(hex) == 1 then
            hex = '0' .. hex
        end
         
        hexadecimal = hexadecimal .. hex
    end
     
    return hexadecimal
end


function Color.GetLowestComponent(color)
    local value = 256
    local name = nil
    local comps = {"r", "g", "b"}
    local array = color:ToArray()
    for i=1, 3 do 
        local val = array[i]
        if val < value then
            name = comps[i]
            value = val
        end
    end
    return value, name
end

function Color.GetHighestComponent(color)
    local value = -1
    local name = nil
    local comps = {"r", "g", "b"}
    local array = color:ToArray()
    for i=1, 3 do 
        local val = array[i]
        if val > value then
            name = comps[i]
            value = val
        end
    end
    return value, name
end


function Color.GetSaturation(color) -- saturation from HSV
    local min = color:GetLowestComponent()
    local max = color:GetHighestComponent()
    return math.floor( 100 - min / max * 100 )
end

function Color.GetValue(color) -- value from HSV
    local value = color:GetHighestComponent()
    return value
end

--- Allow to check for the equality between two Colors using the == comparison operator.
-- @param a (Color) The left member.
-- @param b (Color) The right member.
-- @return (boolean) True if the same components of the two colors are equal (a.r=b.r, a.g=b.g and a.b=b.b)
function Color.__eq(a, b)
    return (a.r == b.r and a.g == b.g and a.b == b.b)
end

function Color.__add( a, b )
    return Color.New( a.r + b.r, a.g + b.g, a.b + b.b )
end  

function Color.__sub( a, b )
    return Color.New( a.r - b.r, a.g - b.g, a.b - b.b )
end
  
function Color.__mul( a, b )
    local new = Color.New(0)
    if type(a) == "table" and type(b) == "number" then
        new.r = a.r * b
        new.g = a.g * b
        new.b = a.b * b
    elseif type(a) == "number" and type(b) == "table" then
        new.r = a * b.r
        new.g = a * b.g
        new.b = a * b.b
    elseif type(a) == "table" and type(b) == "table" then
        new.r = a.r * b.r
        new.g = a.g * b.g
        new.b = a.b * b.b
    end
    return new
end
  
function Color.__div( a, b )
    local new = Color.New(0)
    if type(a) == "table" and type(b) == "number" then
        new.r = a.r / b
        new.g = a.g / b
        new.b = a.b / b
    elseif type(a) == "number" and type(b) == "table" then
        new.r = a / b.r
        new.g = a / b.g
        new.b = a / b.b
    elseif type(a) == "table" and type(b) == "table" then
        new.r = a.r / b.r
        new.g = a.g / b.g
        new.b = a.b / b.b
    end
    return new
end



-- @param color (Color) The color.
-- @return (string) The color's name or nil.
function Color.GetName(color)
    for name, colorArray in pairs( Color.colorsByName ) do
        if color == Color.New( colorArray ) then
            return name
        end
    end
end

--- Returns a string representation of the color's component's values.
-- ie: For a color { r = 10, g = 250, b = 128 }, the returned string would be "10 250 128".
-- Such string can be converted back to a color with string.tocolor()
-- @param color (Color) The color.
-- @return (string) The string.
function Color.ToString( color )
    return color.r.." "..color.g.." "..color.b
end

--- Convert a string representation of a color component's values to a Color.
-- ie: For a string "10 250 128", the returned color would be { r = 10, g = 250, b = 128 }.
-- Such string can be created from a Color with with Color.ToString()
-- @param sColor (string) The color as a string, each component's value being separated by a space.
-- @return (Color) The color.
function string.tocolor( sColor )
    local color = Color.New(0)
    local comps = { "b", "g", "r" }
    for match in string.gmatch( sColor, "[0-9.-]+" ) do
        color[ table.remove( comps ) ] = tonumber(match)
    end
    return color
end


    --[[if Rc:AreTwoComponentsEqual() then
        RComp = Rc:GetLoneComponent()
        Bc[RComp] = 255
        Fc[RComp] = 0

        if RComp == "r" then
            Bc.g = 0
            Bc.b = 0
            -- Red

            Fc.g = 255
            Fc.b = 255
            -- Cyan

            Fo = getOpacity(0, 255, Rc.g)
        elseif RComp == "g" then
            Bc.r = 0
            Bc.b = 0
            -- Green

            Fc.r = 255
            Fc.b = 255
            -- Magenta

            Fo = getOpacity(0, 255, Rc.r)
        elseif RComp == "b" then
            Bc.r = 0
            Bc.g = 0
            -- Blue

            Fc.r = 255
            Fc.g = 255
            -- Yellow

            Fo = getOpacity(0, 255, Rc.r)
        end
    ]]
    