<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Daneel by florentpoujol</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Daneel</h1>
        <p>A framework for CraftStudio</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/florentpoujol/Daneel" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/florentpoujol/Daneel/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/florentpoujol/Daneel/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h1>Daneel</h1>

<p>Daneel is a framework for <a href="http://craftstud.io">CraftStudio</a> that aims to sweeten and shorten the code you write, to extend and render more flexible to use the API, as well as to bring news functionalities.</p>

<p>Daneel never deprecate anything from the current CraftStudio's API which remains usable in its entirety <a href="http://craftstudio.wikia.com/wiki/Scripting_Reference/Index">as described in the scripting reference</a> on the official wiki.<br>
Daneel mostly add new objects, new functions on existing objects and sometimes allow to pass different argument types and new arguments on existing functions.</p>

<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#loading-daneel">Loading Daneel</a></li>
<li><a href="#conventions">Conventions</a></li>
<li><a href="#dynamic-getters-and-setters">Dynamic getters and setters</a></li>
<li><a href="#dynamic-access-to-components">Dynamic access to components</a></li>
<li><a href="#mass-setting-on-gameobjects-and-components">Mass-setting on gameObjects and components</a></li>
<li><a href="#debugging">Debugging</a></li>
<li><a href="#raycasting">Raycasting</a></li>
<li><a href="#trigger-messages">Trigger messages</a></li>
<li><a href="#mouse-messages">Mouse messages</a></li>
<li><a href="#events">Events</a></li>
<li><a href="#hotkeys">Hotkeys</a></li>
<li><a href="#miscellaneous">Miscellaneous</a></li>
<li><a href="#functions-list">Functions list</a></li>
<li><a href="#changelog">Changelog</a></li>
</ul><h2>Overview</h2>

<p>Call getters and setters as if they were variable :</p>

<pre><code>self.gameObject.name -- same as self.gameObject:GetName()
self.gameObject.name = "new name" -- same as self.gameObject:SetName("new name")
</code></pre>

<p>Access any component (including ScriptedBehaviors with a few configuration) on the gameObject in a similar way, like you can already do with the transform :</p>

<pre><code>self.gameObject.modelRenderer

-- the "getters/setters as variable" thing also works on components :
self.gameObject.mapRenderer.map = "folder/map name" -- you can also see here that you can use the map name instead of the map asset

-- writing this same line "the old way" takes twice as much characters :
self.gameObject:GetComponent("MapRenderer"):SetMap(CraftStudio.FindAsset("folder/map name", "Map"))
</code></pre>

<p>Set variable or call setters in mass on gameObjects and components.</p>

<pre><code>gameObject:Set({
    parent = "my parent name",

    modelRenderer = {
        model = "model name"
    }

    myScript = {
        health = 100
    }
})
</code></pre>

<p>Also : </p>

<ul>
<li>Use the gameObject or asset name instead of the actual object with some functions</li>
<li>Simpler raycasting with <code>ray:InstersectsGameObject()</code> or <code>ray:Cast()</code>
</li>
<li>Triggers (they perform a proximity check against some gameObjects and interact with them when they are in range)</li>
<li>Interact with gameObjects hovered by the mouse</li>
<li>Events</li>
<li>Hotkeys (fire events at the push of any button)</li>
</ul><p>You can add the public project <code>Daneel</code> in CraftStudio and run the game to test some of these features for yourself and read some script examples.<br>
Note that the project is only visible in the <code>Community Projects</code> when my computer and my local server are up. Also, my IP changes frequently, so if you can't connect but find it in the <code>Community Projects</code>, you need to remove the project from your list then add it again.</p>

<h2>Installation</h2>

<p>First <a href="http://florent-poujol.fr/content/craftstudio/daneel/craftstudio_daneel_v1.1.0.cspack">download the package of scripts from this link</a>.</p>

<p>You must then import the package in your project.</p>

<ul>
<li>Download the file on your computer</li>
<li>Go to your project's administration, "Import/Export" section.<br>
</li>
<li>Click the import button (top right), navigate to the location you downloaded the pack in then click "Open".<br>
</li>
<li>Navigate to the "Script" tab, select all the scripts then click "Import".</li>
</ul><h2>Configuration</h2>

<p>Some features only work if a few configuration is done first.
You will find the configuration table in the <code>Daneel/Config</code> script.</p>

<h2>Loading Daneel</h2>

<p>Daneel needs to be loaded before some of its features work, so you need to add the "Daneel/Behaviors/DaneelBehavior" script as a ScriptedBehavior in your scene.<br>
Daneel is garanteed to be loaded by the time functions <code>Behavior:Start()</code> begin to be called.<br>
It may also be the case from <code>Behavior:Awake()</code> functions, but it is not garanteed (it depends on the GameObject initialization order).</p>

<p>The global variable <code>DANEEL_LOADED</code> is equal to <code>nil</code> until Daneel is loaded, where its value is set to <code>true</code>.</p>

<p>Any scripts whose path is set in <code>Daneel.config.scripts</code> may implements a <code>Behavior:DaneelAwake()</code> function.<br>
This function will be called right after Daneel has loaded, before <code>Behavior:Start()</code> and <strong>even on scripts that are not ScriptedBehavior</strong>.</p>

<h2>Conventions</h2>

<ul>
<li>Every getter functions are called GetSomething() instead of FindSomething().</li>
<li>Every object and function names are pascal-cased, except for functions added to Lua's standard libraries which are all lower-case.</li>
<li>Every time an argument has to be an asset (like with <code>modelRenderer:SetModel()</code>), you may pass the fully-qualified asset name instead.</li>
<li>Every time an argument has to be a gameObject instance (like with <code>gameObject:SetParent(parentNameOrInstance[, keepLocalTransform])</code>), you may pass the gameObject name instead.</li>
<li>Every time an argument has to be an asset or component type, it is case insensitive.</li>
<li>Every optional boolean arguments default to false.</li>
</ul><h2>Dynamic getters and setters</h2>

<p>Getters and setters functions may be used on gameOjects, components and assets as if they were variables. Their names must begin by "Get" or "Set" and have the forth letter upper-case (underscore is allowed). Ie : GetSomething() and Get_something() will work, but Getsomething() or getSomething() won't work.</p>

<pre><code>self.gameObject.transform.localPosition
-- is the same as
self.gameObject.transform:GetLocalPosition()

self.gameObject.name = "a new name"
-- is the same as 
self.gameObject:SetName("a new name")
-- note that only one argument (in addition to the working object) can be passed to the function.
</code></pre>

<p>Dynamic getters and setters will also work on your ScriptedBehaviors provided you add their Script's fully-qualified path in <code>Daneel.config.scripts</code> :</p>

<pre><code>Daneel.config = {
    scripts = {
        "MyScript",
        "folder/my other script", 
    }
}
</code></pre>

<h2>Dynamic access to components</h2>

<p>As Daneel introduce the new <code>gameObject:GetModelRenderer()</code>, <code>gameObject:GetMapRenderer()</code> and <code>gameObject:GetCamera()</code> functions, you may now access any component via its variable, like the transform :</p>

<pre><code>self.gameObject.modelRenderer.model = Asset.GetModel("model name") -- Asset.GetModel() is an helper of Asset.Get(), an alias of CraftStudio.FindAsset()
-- is the same as
self.gameObject:GetComponent("ModelRenderer"):SetModel(CraftStudio.FindAsset("model name", "Model"))
</code></pre>

<h3>ScriptedBehaviors</h3>

<p>ScriptedBehaviors may also be accessed this way.<br>
It just works right away for those who are not nested in a folder and name is pascal-cased. For instance, with a Script whose name is "MyScript" :</p>

<pre><code>self.gameObject.myScript
-- is the same as
self.gameObject:GetScriptedBehavior(CraftStudio.FindAsset("MyScript", "Script"))
</code></pre>

<p>ScriptedBehaviors who are nested in folders and/or name are not pascal-cased, may be accessed via their aliases as you define them in <code>Daneel.config.scripts</code>.</p>

<pre><code>Daneel.config = {
    scripts = {
        "MyScript",

        -- alias = "fully-qualified Script path"
        otherScript = "folder/my other script",
    }
}

-- in your script, access the scripteBehavior via its alias :
self.gameObject.otherScript
</code></pre>

<h2>Mass-setting on gameObjects and components</h2>

<p>Functions <code>gameObject:Set()</code> and <code>component:Set()</code> accept a "params" argument of type table which allow to set variables or call setters in mass.  </p>

<pre><code>gameObject:Set({
    parent = "my parent name", -- Set the parent via SetParent()
    myScript = {
        health = 100 -- Set the variable health or call SetHealth(100) if it exists on the 'MyScript' scriptedBaheavior 
    }
})

modelRenderer:Set({
    localOrientation = Quaternion:New(1,2,3,4), -- set the local orientation via SetLocalOrientation()
    randomVariable = "random value"
})
</code></pre>

<h3>Component mass-creation and setting on gameObjects</h3>

<p>With <code>gameObject:Set()</code>, you can easily create new components then optionally initialize them or set existing components (including ScriptedBehaviors).  </p>

<pre><code>gameObject:Set({
    modelRenderer = {
        model = "Model name"
    }, -- will create a modelRenderer if it does not yet exists, then set its model

    camera = {}, -- will create a camera component then do nothing, or just do nothing

    scriptedBehavior = "Script name", -- will create a ScriptedBehavior with the "Script name" script if it does not yet exists

    scriptedBehaviors = {
        "script name 2",
        "script name 3", -- will create those ScriptedBehaviors if they don't yet exist

        ["script name 4"] = {
            variableOrSetter = value
        } -- will create a ScriptedBehavior if it does not yet exists, then set it
    },

    scriptAlias = {
        variableOrSetter = value
    } -- will set the ScriptedBehavior whose name or alias is 'ScriptAlias'
})
</code></pre>

<p><strong>Components</strong></p>

<p>Just set the variable of the same name as the component with the first letter lower case. Set the value as a table of parameters. If the component does not yet exists, it will be created. If you want to create a component without initializing it, just leave the table empty.</p>

<p>You can also mass-set existing components on gameObjects via <code>gameObject:SetComponent()</code> or its helpers (<code>gameObject:SetModelRenderer()</code> and the likes).</p>

<pre><code>self.gameObject:SetMapRenderer({params})

-- or (with the dynamic component getters)
self.gameObject.mapRenderer:Set({params})

-- note that you CAN NOT do the following since the components are cached on the gameObject :
self.gameObject.mapRenderer = {params}
-- the variable actually exists on the gameObject, so the dynamic call to Set[ComponentType]() does not work
</code></pre>

<p><strong>ScriptedBehaviors</strong></p>

<p>If you want to add just one scriptedBehavior, you can set the variable <code>scriptedBehavior</code> with the script name or asset as value.<br>
If you want to add one or more scriptedBehaviors and maybe initialize them or set existing ScriptedBehaviors, set the variable <code>scriptedBehaviors</code> (with an "s" at the end) with a table as value.<br>
This table may contains the script name or asset of new ScriptedBehaviors as value (if you don't want to initialize them) or the script name or asset as key and the parameters table as value (for new or existing ScriptedBehaviors). Existing ScriptedBehaviors may also be set via their name or alias.</p>

<h2>Debugging</h2>

<p>For an easy debugging during development, Daneel feature extensive error reporting and a stack trace. Since these features are pretty heavy on function calls, you can turn these on and off (and you should disable debug when you ship your game).<br>
It's turned off by default, so just set the value of the variable <code>Daneel.config.debug</code> to <code>true</code> to enable it.</p>

<h3>Error reporting</h3>

<p>In every functions introduced or modified by Daneel, every arguments are checked for type and value and a comprehensive error message is thrown if needed.<br>
For instance, passing false instead of the gameObject's name with <code>gameObject:GetChild()</code> would trigger the following error :  </p>

<pre><code>GameObject.GetChild(gameObject, name[, recursive]) : Argument 'name' is of type 'boolean' with value 'false' instead of 'string'.
</code></pre>

<h3>Stack Trace</h3>

<p>When an error is triggered, Daneel print a "stack trace" in the Runtime Report.
The stack trace nicely shows the history of function calls within the framework that lead to the error and display values received as argument.<br>
It reads from top to bottom, the last function called -where the error occurred- at the bottom.<br>
For instance, when trying to set the model of a ModelRenderer (to a Model that does not exists) via gameObject:Set() :</p>

<pre><code>~~~~~ Daneel.Debug.StackTrace ~~~~~
#01 GameObject.Set(GameObject: 'Object1': 14476932, table: 04DAC148)
#02 Component.Set(ModelRenderer: 31780825, table: 04DAC238)
#03 ModelRenderer.SetModel(ModelRenderer: 31780825, "UnknowModel")
[string "Behavior Daneel/Daneel (0)"]:293: ModelRenderer.SetModel(modelRenderer, modelNameOrAsset) : Argument 'modelNameOrAsset' : model with name 'UnknowModel' was not found.
</code></pre>

<h3>Data types</h3>

<p>The function <code>Daneel.Debug.GetType(object)</code> may returns any of the built-in Lua types or the name of any of the objects introduced by CraftStudio or Daneel : GameObject, ModelRenderer, MapRenderer, Camera, Transform, Script, Model, ModelAnimation, Map, TileSet, Scene, Sound, Ray, RaycastHit, Vector3, Plane or Quaternion.</p>

<p>It can also return your own types as you define them in <code>Daneel.config.objects</code>. GetType() will return the type for tables that have the object table as a metatable.</p>

<h2>Raycasting</h2>

<p>GameObjects who have the <code>CastableGameObject</code> ScriptedBehavior are known as <strong>castable gameObjects</strong>.<br>
The <code>RaycastHit</code> object stores the information regarding the collision between a ray and a gameObject. It may contains the keys distance, normal, hitBlockLocation, adjacentBlockLocation, gameObject and componentType.</p>

<p>The function <code>ray:IntersectsGameObject(gameObject)</code> returns a RaycastHit if the ray intersects the gameObject, or nil.<br>
The function <code>ray:Cast([gameObjects])</code> cast the ray against all castable gameObjects (or against the provided set of gameObjects) and returns a table of RaycastHit (which will be empty if no gameObjects have been hit).</p>

<h2>Trigger messages</h2>

<p>GameObjects who have the <code>TriggerableGameObject</code> ScriptedBehavior are known as <strong>triggerable gameObjects</strong>. They react when they are near triggers.<br>
Triggers are gameObjects that perform a spherical proximity check each frames against all triggerable gameObjects.<br>
Triggers must have the <code>Trigger</code> ScriptedBehavior and you must set its <code>radius</code> public property (don't forget to tick the box).</p>

<ul>
<li>When a triggerable gameObject enters a trigger for the first frame (it is in range this frame, but it wasn't the last frame), the message <code>OnTriggerEnter</code> is sent on the gameObject.<br>
</li>
<li>As long as a gameObject stays in range of one or several trigger(s), the message <code>OnTriggerStay</code> is sent on the gameObject (each frame, by each trigger the gameObject is in range of).</li>
<li>The frame a gameObject leaves a trigger's radius (it is not in range this frame but was in range the last frame), the message <code>OnTriggerExit</code> is send on the gameObject.</li>
</ul><p>Each of these functions receive the trigger gameObject as argument.</p>

<pre><code>-- in a ScriptedBehavior attached to a triggerable gameObjects :
function Behavior:OnTriggerEnter(trigger)
    print("The gameObject of name '"..self.gameObject.name.."' just reach the trigger of name '"..trigger.name.."'.")
end

function Behavior:OnTriggerStay(trigger)
    if CraftStudio.Input.WasButtonJustRealeased("Action") then
        print("The 'Action' button was just released while the gameObject of name '"..self.gameObject.name.."' is inside the trigger of name '"..trigger.name.."'.")
    end
end
-- a typical use for this is any mechanism that the player can use if he is close enough and press a key
</code></pre>

<h2>Mouse messages</h2>

<p>GameObjects who have the <code>MousehoverableGameObject</code> ScriptedBehavior are known as <strong>mousehoverable gameObjects</strong>. They react when they are hovered by the mouse.<br>
Add the <code>CameraMouseOver</code> ScriptedBehavior to your camera.</p>

<ul>
<li>When a mousehoverable gameObject is hovered for the first frame (it is hovered this frame, but it wasn't the last frame), the message <code>OnMouseEnter</code> is sent on the gameObject.</li>
<li>As long as the mouse stays over the gameObject, the message <code>OnMouseOver</code> is sent on the gameObject.</li>
<li>The frame the mouse stop hovering over a mousehoverable gameObject (it is not hovered this frame but was hovered the last frame), the message <code>OnMouseExit</code> is send on the gameObject.</li>
</ul><h2>Events</h2>

<p>Daneel provide a event system that allows to run functions or messages on gameObjects whenever some events happens during runtime.</p>

<p>You can register global or local functions to be called whenever an event is fired (the function is said to listen to the event).<br>
Any arguments may be passed to the function when the event is fired.  </p>

<pre><code>local function ALocalFunction(text)
    print(text)
end

function Behavior:Awake()
    Daneel.Events.Listen("EventName", ALocalFunction) -- same for global functions

    -- to fire an event, just call the Fire() function
    -- and optionally pass the argument(s) after the event name
    Daneel.Events.Fire("EventName", "Brace for this event !")
end
</code></pre>

<p>You can also make gameObjects to listen to events. By default, the message of the same name as the event will be sent (and optionally broadcasted) on that gameObject (the function <code>Behavior:EventName()</code> wil be called if it exists).  </p>

<pre><code>function Behavior:Awake()
    Daneel.Events.Listen("EventName", self.gameObject) -- the message "EventName" will be sent on this gameObject only
    Daneel.Events.Listen("EventName", self.gameObject, "AnotherMessage") -- the message "AnotherMessage" (instead of "OnEventName") will be sent on this gameObject only
    Daneel.Events.Listen("EventName", self.gameObject, "AnotherMessage", true) -- the message "AnotherMessage" will be sent on this gameObject and all of its children
end
</code></pre>

<p>If you want a function or a gameObject to listen to every events, just pass <code>"any"</code> as the event name.</p>

<h2>Hotkeys events</h2>

<p>Whenever you press one of the button whose name is set in <code>Daneel.config.buttons</code>, the events named <code>On[Button name]ButtonJustPressed</code>, <code>On[Button name]ButtonDown</code> and <code>On[Button name]ButtonJustReleased</code> are fired.</p>

<p>The table <code>Daneel.config.buttons</code> may be filled with the button names that you defined in the <code>Administration &gt; Game Controls</code> tab.</p>

<pre><code>Daneel.config = {
    buttons = {
        "Action",
        "fire",
    }
}
</code></pre>

<h2>Miscellaneous</h2>

<h3>GameObject</h3>

<ul>
<li>Create a gameObject with <code>GameObject.New()</code> or <code>GameObject.Instantiate()</code>.</li>
<li>Get a gameObject with <code>GameObject.Get()</code> and get a child with <code>gameObject:GetChild()</code>.</li>
<li>Add a component on a gameObject with <code>gameObject:AddComponent()</code> or its helpers <code>gameObject:AddModelRenderer()</code> and the likes, as well as <code>gameObject:AddScriptedBehavior()</code>.</li>
<li>Send a message to a gameObject and all of its descendants with <code>GameObject.BroadcastMessage()</code>
</li>
</ul><h3>Asset</h3>

<p>Get an asset with <code>Asset.Get()</code> or its helpers <code>Asset.GetScript()</code>, <code>Asset.GetModel()</code>, ...</p>

<h3>Scene</h3>

<p>Load a scene with <code>Scene.Load()</code>, append a scene with <code>Scene.Append()</code>.</p>

<h3>Tables as object</h3>

<p>Tables returned by <code>table.new()</code> or any new table functions introduced by Daneel that returns a table may be used in an object-oriented way. You can also turn any standard table to such table by passing it as argument to table.new().  </p>

<pre><code>-- you always can do this :
table.insert(myTable, value)

-- now, you can also do this (like with strings)
myTable:insert(value)
</code></pre>

<p>The <code>table</code> object has also been extended with many functions that ease the manipulation of tables.</p>

<h2>Functions list</h2>

<p><a href="http://florent-poujol.fr/content/craftstudio/daneel/doc/">See the full function reference</a> for full explanation on arguments and returned values. 
Arguments between square brackets are optional.</p>

<h3>Asset</h3>

<ul>
<li>Asset.Get(assetName[, assetType])

<ul>
<li>Asset.GetScript(assetName)</li>
<li>Asset.GetModel(assetName)</li>
<li>Asset.GetModelAnimation(assetName)</li>
<li>Asset.GetMap(assetName)</li>
<li>Asset.GetTileSet(assetName)</li>
<li>Asset.GetScene(assetName)</li>
<li>Asset.GetSound(assetName)</li>
</ul>
</li>
</ul><h3>Component</h3>

<ul>
<li>Component.Set(component, params)</li>
<li>component:Destroy()</li>
</ul><h3>Daneel.Debug</h3>

<ul>
<li>Daneel.Debug.CheckArgType(argument, argumentName, expectArgumentType[, errorHead, errorEnd])</li>
<li>Daneel.Debug.CheckOptionalArgType(argument, argumentName, expectArgumentType[, errorHead, errorEnd])</li>
<li>Daneel.Debug.CheckComponentType(componentType)</li>
<li><p>Daneel.Debug.CheckAssetType(assetType)</p></li>
<li><p>Daneel.Debug.GetType(object[, getLuaTypeOnly])</p></li>
<li><p>error(message[, doNotPrintStacktrace])</p></li>
<li><p>Daneel.Debug.ToRawString(object)</p></li>
<li><p>Daneel.Debug.StackTrace.BeginFunction(functionName[, ...])</p></li>
<li><p>Daneel.Debug.StackTrace.EndFunction()</p></li>
<li><p>Daneel.Debug.StackTrace.Print()</p></li>
</ul><h3>Daneel.Events</h3>

<ul>
<li>Daneel.Events.Listen(eventName, function) / Daneel.Events.Listen(eventName, gameObject[, functionName, broadcast])</li>
<li>Daneel.Events.StopListen(eventName, functionOrGameObject)</li>
<li>Daneel.Events.Fire(eventName[, ...])</li>
</ul><h3>Daneel.Utilities</h3>

<ul>
<li>Daneel.Utilities.CaseProof(name, set)</li>
</ul><h3>GameObject</h3>

<ul>
<li>GameObject.New(name[, params])</li>
<li>GameObject.Instantiate(name, sceneNameOrObject[, params])</li>
<li><p>GameObject.Get(name)</p></li>
<li><p>gameObject:SetParent(parentNameOrInstance[, keepLocalTransform])</p></li>
<li><p>gameObject:GetChild(childName[, recursive])</p></li>
<li><p>gameObject:GetChildren([recursive, includeSelf])</p></li>
<li><p>gameObject:SendMessage(functionName[, data])</p></li>
<li><p>gameObject:BroadcastMessage(functionName[, data])</p></li>
<li>
<p>gameObject:AddComponent(componentType[, params]) / gameObject:AddComponent("ScriptedBehavior", scriptNameorAsset[, params])</p>

<ul>
<li>gameObject:AddScriptedBehavior(scriptNameOrAsset[, params])</li>
<li>gameObject:AddModelRenderer([params])</li>
<li>gameObject:AddMapRenderer([params])</li>
<li>gameObject:AddCamera([params])</li>
</ul>
</li>
<li>
<p>gameObject:SetComponent(componentType, params) / gameObject:SetComponent("ScriptedBehavior", scriptNameorAsset, params)</p>

<ul>
<li>gameObject:SetScriptedBehavior(scriptNameOrAsset, params)</li>
<li>gameObject:SetModelRenderer(params)</li>
<li>gameObject:SetMapRenderer(params)</li>
<li>gameObject:SetCamera(params)</li>
<li>gameObject:SetTransform(params)</li>
</ul>
</li>
<li>
<p>gameObject:GetComponent(componentType[, scriptNameOrAsset])</p>

<ul>
<li>gameObject:GetScriptedBehavior(scriptNameOrAsset)</li>
<li>gameObject:GetModelRenderer()</li>
<li>gameObject:GetMapRenderer()</li>
<li>gameObject:GetCamera()</li>
</ul>
</li>
<li><p>gameObject:Destroy()</p></li>
</ul><h3>math</h3>

<ul>
<li>math.isinteger(value[, errorIfValueIsNotNumber])</li>
</ul><h3>MapRenderer</h3>

<ul>
<li>mapRenderer:SetMap(mapNameOrAsset[, keepTileSet])</li>
<li>mapRenderer:SetTileSet(tileSetNameOrAsset)</li>
</ul><h3>ModelRenderer</h3>

<ul>
<li>modelRenderer:SetModel(modelNameOrAsset)</li>
<li>modelRenderer:SetAnimation(animationNameOrAsset)</li>
</ul><h3>Ray</h3>

<ul>
<li>ray:Cast([gameObjects])</li>
<li>ray:IntersectsGameObject(gameObjectNameOrInstance)</li>
</ul><h3>RaycastHit</h3>

<ul>
<li>RaycastHit.New([distance, normal, hitBlockLocation, adjacentBlockLocation, gameObject])</li>
</ul><h3>Scene</h3>

<ul>
<li>Scene.Load(sceneNameOrAsset)</li>
<li>Scene.Append(sceneNameOrAsset, gameObjectNameOrInstance)</li>
</ul><h3>string</h3>

<ul>
<li>string.totable(string)</li>
<li>string.isoneof(string, set[, ignoreCase])</li>
<li>string.ucfirst(string)</li>
</ul><h3>table</h3>

<ul>
<li>table.new([table])</li>
<li>table.copy(table)</li>
<li>table.constainskey(table, key)</li>
<li>table.constainsvalue(table, value[, ignoreCase])</li>
<li>table.length(table[, keyType])</li>
<li>table.print(table)</li>
<li>table.printmetatable(table)</li>
<li>table.merge(...)</li>
<li>table.compare(table1, table2)</li>
<li>table.combine(keys, values[, returnFalseIfNotSameLength])</li>
<li>table.removevalue(table, value[, singleRemove])</li>
<li>table.getkeys(table)</li>
<li>table.getvalues(table)</li>
<li>table.getkey(table, value)</li>
</ul><h2>Changelog</h2>

<h3>v1.1.0</h3>

<ul>
<li>Separated the user config from the "Daneel" script</li>
<li>Dynamic getters and setters works on assets too</li>
<li>Daneel.Debug.getType() may now also return user-defined types</li>
<li>The error() function now prints the StackTrace, unless told otherwise (Daneel.Debug.PrintError() is removed)</li>
<li>Default function names when registering a gameObject to an event are not prefixed by "On" anymore</li>
<li>Fixed various bugs</li>
</ul>
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/florentpoujol">florentpoujol</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="http://twitter.com/#!/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>